#+TITLE: 《The Command Line Book》学习笔记
[[http://linuxcommand.org/tlcl.php/tlcl.php][书籍地址]]

* Learning The Shell
** 初试Shell
   命令行打开快捷键：<C-Alt-T>

   #+BEGIN_EXAMPLE
     me@ubuntu16.04:~$
   #+END_EXAMPLE

   以上格式含义为：用户名@电脑名:当前文件夹和$。 如果不是$，而是以
   “#”结尾表示为超级用户权限。

   导航：
   - <Up>：上一个命令
   - <Down>：下一个命令
   - <Left> <Right>：光标左右移动

   与Emacs相同的导航快捷键：
   - <C-p> ： 上一个命令
   - <C-n> ： 下一个命令
   - <C-f> 和 <C-b> ：光标左右移动

   一些简单命令：
   - *date* ：获取当前时间和日期。
   - *cal* ：显示日历。
   - *df* ：硬盘使用。
   - *free* ：内存使用情况。
   - *exit* ：退出命令行。

** 文件导航
   - *pwd* ：显示当前文件夹。
   - *ls* ：列出当前文件夹中的内容。
   - *cd* ：在文件夹中跳转。特殊用法：
     | 参数       | 效果                       |
     | cd         | 跳转到home文件夹           |
     | cd         | 跳转到上次打开的文件夹     |
     | cd ~用户名 | 跳转到"用户名"的home目录下 |
** 系统文件
*** 使用ls列出文件内容的其它用法
    *ls DIR1 FILE1* ：列出多个文件。
	参数：
    | 缩写 | 全写选项     | 作用                           |
    | a    | all          | 列出包含隐藏文件的所有文件     |
    | A    | almosall     | 同上，只是不含上级目录和根目录 |
    | d    | directory    | 单纯列出文件夹，不列出其中内容 |
    | F    | classify     | 如果为文件夹，后跟“/”          |
    | h    | humareadable | 增加文件大小可读性             |
    | l    | long         | 列出详细信息                   |
    | r    | reverse      | 逆序                           |
    | S    |              | 按文件大小排序                 |
    | t    |              | 按时间顺序                     |

	显示文件详细信息时列出的内容格式为：

	#+BEGIN_EXAMPLE
     me@ubuntu16.04:~$ ls -lh
     drwxxx  4 me me 4.0K 8月  10 19:32 dwhelper
	#+END_EXAMPLE

    drwxxx：第一个字符区分是文件还是文件夹，"d"表示文件夹，"表
    示文件；后3个字符表示所属用户读写权限；再后3个字符表示工作组成员
    读写权限？；最后3个字符表示其它用户读写权限。
	- 4：硬链接数量。
	- me：文件所属者。
	- me：文件所属组？
	- 4.0k：文件大小。
	- 8月 10 19:32：修改时间。
	- dwhelper：文件名。

*** 使用file查看文件类型
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~/Pictures$ file P6071183321.jpg
      P6071183321.jpg: JPEG image data, Exif standard: [TIFF image data, littlendian, direntries=18, GPData, model=m2]
	#+END_EXAMPLE
*** 使用less查看文件内容
	阅读快捷键与Vi相同。
*** 系统目录概览
	- /： 根目录，包含所有文件。
	- /bin：系统启动和运行时必须的文件。
	- /boot：含Linux内核、initial RAM disk image (for drivers needed
      at boot time)和启动加载器（boot loader）。 比如：
	  - /boot/grub/grub.cfg：用于配置启动加载器。
	  - /boot/vmlinuz（名称可能不一）：Linux内核
	- /dev：所有设备（device）的列表。
	- /etc：包含所有应用于整个系统的配置文件，以及系统服务启动的shell
      脚本。所有文件都为纯文本文件。 比如：
	  - /etc/fstab：储存设备及其挂载点。
	  - /etc/crontab：automated jobs何时启动。
	  - /etc/passwd：用户账号信息。
	- /home：普通用户文件操作区域。
	- /lib：包含系统核心程序公用库文件（与Window的DLL文件类似）。
	- /lost+found：系统崩溃后恢复使用。如果系统不出现严重错误，此文件夹为空。
	- /media：如USB和CROM等移动设备的挂载点文件。
	- /mnt：老旧Linux系统中，该文件夹含手动挂载的移动设备文件。
	- /opt：主要用于保存商业软件。
	- /proc：其内容并不在硬盘中，只含内核的虚拟文件。其中文件可读，说
      明内核如何读取电脑信息。
	- /root：root用户的根目录。
	- /sbin：含超级用户执行重要系统任务所需二进制文件。
	- /tmp：含不同程序执行时创建的临时文件。通过配置，可实现系统重启时，
      不含任何内容。
	- /usr：最大的文件夹。含普通用户的所有程序和支持文件。
	- /usr/bin：不同Linux分支安装的执行文件。容量很多。
	- /usr/lib：含/usr/bin文件夹中的共享库文件。
	- /usr/local：不含Linux分支程序，而含整个系统使用程序？。通过源码
      编译安装的程序在/usr/local/bin文件夹中。系统安装后就有此文件夹，
      但当管理员安装某些程序后，此文件夹才有内容。
	- /usr/sbin：含其它管理员安装程序。
	- /usr/share：含与/usr/bin文件夹下的程序共享的所有数据，比如配置文
      件、图标、屏幕背景和声音文件等。
	- /usr/share/docs：绝大多数安装软件都有文档，就放置在其中。
	- /var：除/tmp和/home外，其它文件夹相对静态，改变不大。此文件夹主
      要存储更新频繁的数据，如数据库和用户邮件等。
	- /var/log：含日志文件，记录系统活动情况。其中最有用的是
      /var/log/message和（或）/var/log/syslog文件。出于安全考虑，需将
      其权限设置为超级用户。

*** 软链接（Symbolic Links或Soft Links）
	使用"ls"命令时，有时会出现类似如下的结果，其中>"表示该文件有软链接：

	#+BEGIN_EXAMPLE
	lrwxrwxrwx 1 me me 11 200011 07:34 libc.so.6> lib2.6.so
	#+END_EXAMPLE

	比如某个程序需共享"foo"文件，而此文件版本更新频繁，可在文件名后增
	添版本号。不过，如果此文件每次更新后，需更改共享此文件程序的软件配
	置。

	软链接的作用就在于，比如现在安装了2.6版本的"foo"，文件名为
	"fo2.6"。此时就可创建一个软链接"foo"指向"fo2.6"，读取"foo"文件
	时实质上是读取的"fo2.6"文件。当更新至2.7版本时，重置此软链接即可。

*** 硬链接
	既然有软链接，也有硬链接，也可使文件有多个名字，不过机制不同，下章介绍。

** 文件操作
   - *cp* ：复制文件
   - *mv* ：移动/重命名文件
   - *mkdir* ：创建文件夹
   - *rm* ：删除文件
   - *ln* ：创建软链接和硬链接

*** 通配符（Wildcard/Globbing）
	使用通配符可快速选择和过滤文件,通配符有：

    | \*            | 匹配任意长度的任意字符             |
    | ?             | 匹配一个字符                       |
    | [characters]  | 匹配任意一个characters中的字符     |
    | [!characters] | 匹配任意一个不是characters中的字符 |
    | [ [:class:] ] | 匹配满足class的一个字符            |

	其中class可为:

    | [:alnum:] | 字母或数字 |
    | [:alpha:] | 字母       |
    | [:digit:] | 数字       |
    | [:lower:] | 小写字母   |
    | [:upper:] | 大写字母   |

	举例:

    | \*                | 所有文件                                      |
    | g*                | 所有以g开头的文件                             |
    | b*.txt            | 所有以b开头,中间为任意字符,再以.txt结尾的文件 |
    | Data???           | 以Data开头的,后跟3个字符的文件                |
    | [abc]*            | 以a,b或c开头的文件                            |
    | [ [:upper:] ]*    | 以大写字母开头的文件                          |
    | [ ![:digit] ]*    | 以非数字开头的文件                            |
    | *[ [:lower:]123]  | 以一个小写字母或1,2,3j结尾的文件              |
*** mkdir ...
	可同时创建多个文件夹
*** cp 复制文件
	参数：

    |archive             | 同时复制所有权和权限           |
    |interactive         | 如需覆盖已有文件，询问         |
    |recursive           | 同时复制子文件夹               |
    |update              | 只复制目标文件夹中不存在的文件 |
    |verbose             | 显示详细信息                   |

	例子：

    | cp file1 file2      | 复制file1到file2。如果file2已存在，覆盖；不存在，创建              |
    | cpi file2 file2     | 如果file2已存在，提示是否覆盖                                      |
    | cp file1 file2 dir1 | 将file1和file2复制到dir1文件夹。dir1需已存在                       |
    | cp dir1/* dir2      | 将dir1中的所有文件复制到dir2。dir2需已存在}                        |
    | cpr dir1 dir2       | 将dir1中的所有内容复制到dir2。如果dir2不存在，创建；已存在，仅复制 |
*** mv 移动或重命名文件
	参数和用法与cp相似，只是操作完成后原文件会被删除。
*** rm 删除文件
	参数：
    |interactive       | 删除前提醒                                          |
    |recursive         | 如果是文件夹，且删除其中的子文件夹，需添加此选项    |
    |force             | 不管文件是否存在，都删除。可interactive选项       |
    |verbose           | 显示操作信息                                        |

	例子：
    | rm file1          | 删除file1                                               |
    | rmi file1         | 同上例唯一不同在于，删除前提醒                          |
    | rmr file1 dir1    | 删除file1，删除dir1及其中内容                           |
    | rmrf file1 dir1   | 与上例唯一不同在于，不管file1和dir1是否存在，都执行命令 |
*** ln 创建链接

	创建连接：
	#+BEGIN_EXAMPLE
	me@ubuntu16.04:~$ ln file link
	#+END_EXAMPLE

	创建软链接：
	#+BEGIN_EXAMPLE
	me@ubuntu16.04:~$ lns item link
	#+END_EXAMPLE

**** 硬链接
	 硬链接是Unix创建链接的传统方式，不如软链接先进。每个文件默认有一
	 个为其名字创建的硬链接。自行创建硬链接时，实质上是为文件创建了额
	 外文件夹入口？。硬链接有两大不足：

	 不能在不同分区间创建硬链接。
	 只能为文件，不能为文件夹创建硬链接。

	 与软链接不同，当使用"lsl"命令查看时，硬链接文件的显示方式与普通
	 文件无区别。当硬链接被删除时，只是链接被删除，但所占内存依然存在，
	 当指向该文件的所有链接都被删除后才释放。 _尽量避免使用硬链接。_
**** 软连接
	 软链接的目的就是弥补硬链接的短处。如果为文件或文件夹创建软链接，
	 则生成一个特殊文件，含一个指向引用文件或文件夹的文本指针。

	 如果修改软链接中的内容，引用文件中的内容也会随之改变。删除软链接
	 后，引用文件并不被删除；如果文件先被删除，软链接依然存在，只是不
	 指向任何文件，此状态为软链接被损坏，当使用"ls"命令时，会使用不同
	 的颜色显示。
*** 实践
** 充分利用命令行
   - *type* ：命令来源
   - *which* ：命令对应的执行程序位置
   - *help* ：内置shell命令帮助文档
   - *man* ：显示命令的手册页
   - *apropos* ：通过手册文件查找命令
   - *info* ：显示命令的info文件
   - *whatis* ：显示命令的精简描述
   - *alias* ：为命令取一个别名（alias）
	 创建前先通过 *type* 命令查看是否存在，避免冲突。

	 不带任何参数可查看所有已创建的别名。
   - *unalias* ：删除别名。

   命令可分4大类：
   1. *可执行程序* 比如/usr/bin内的文件。此类程序也可为编程语言（如
      C等）编译成的二进制文件。
   2. *shell内置命令（shell buitins）* 如"cd"命令。
   3. *shell脚本*
   4. *别名（alias）* 使用其它命令创建的命令。

** 重定向
   - *cat* ：合并文件
   - *sort* ：排序文本
   - *uniq* ：显示/排除重复行
   - *grep* ：使用正则匹配行
   - *wc* ：统计行数、单词数和字节数（byte）
   - *head* ：显示文件前面部分
   - *tail* ：显示文件后面部分
   - *tee* ：从标准输入流读入，写入文件同时还可在管道中传递

*** 标准输入流、输出流和错误流

	目前为止学习到的命令都会有输出内容，其主要有两类：程序执行结果，状态和
	错误信息。

	按Unix"一切皆文件"的说法，以"ls"命令为例，其结果输入到标准输出流
	（stdout）这一特殊文件，状态和错误信息输入到标准错误流（stderr）另外一
	个特殊文件。默认情况下，者两个文件只是关联到显示屏，不对向硬盘写入任何
	数据。

	此外，标准输入流（stdin）则默认关联到键盘。

	重定向标准流后，可使输出不止在显示屏上，输入不止来自键盘。
*** 重定向标准输出流
	使用重定向操作符">"可将标准输出流从显示屏重定向到文件。如果对文件
	操作，会先清空文件内容。

	使用重定向操作符">>"可向文件末尾追加内容，不用完全改写。
*** 重定向标准错误流
	重定向错误流没有专门的操作符，需使用类型编号。0,1和2分别代表标准输入流输出流和错误流。

	#+BEGIN_EXAMPLE
	me@ubuntu16.04:~$ lsl /bin/usr 2> lerror.txt
	#+END_EXAMPLE
*** cat命令参数
	|shoall                 | 等价vET                                    |
	|numbenonblank          | 只为非空行显示行数，可重n选项              |
	|e                      | 等价vE                                     |
	|shoends                | 每行末尾显示"$"                             |
	|n                      | 为每行显示行数                              |
	|squeezblank            | 将重复空行合并为一行                        |
	|t                      | 等价vT                                     |
	|shotabs                | 将TAB字符显示为^I                           |
	|shononprinting         | 使用^和形式显示不可打印字符，LFD和TAB除外   |

** 命令处理
   *echo* ：输出。
   #+BEGIN_EXAMPLE
	 me@ubuntu16.04:~$ echo this is a test
	 this is a test
   #+END_EXAMPLE

   输入命令，按下Enter后，如”\*“，bash将命令处理后，shell才执
   行。bash处理的过程称为膨胀（expansion)。

*** 命令膨胀
**** 路径膨胀 *
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo D*
       Desktop Documents Downloads
       me@ubuntu16.04:~$ echo *s
       Documents Downloads Pictures Templates Videos
       me@ubuntu16.04:~$ echo [[:upper:]]*
       Desktop Documents Downloads Music Pictures Public Templates Videos
	 #+END_EXAMPLE
**** 波浪字符膨胀 ~
	 与cd命令相同，“~”表示用户的home文件夹路径。

	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo ~
	 #+END_EXAMPLE
**** 数学运算膨胀 $(())
	 基本形式：
	 #+BEGIN_EXAMPLE
	 echo $((2 + 2))
	 #+END_EXAMPLE

	 嵌套形式：
	 #+BEGIN_EXAMPLE
	 me@ubuntu16.04:~$ echo $(( (5**2) * 3 ))
	 #+END_EXAMPLE

	 *不支持浮点数，如5/2的结果为2 。*

	 支持的运算有：
     | +  | 加   |
     | -  | 减   |
     | *  | 乘   |
     | /  | 除   |
     | %  | 求模 |
     | ** | 次方 |

**** 花括号膨胀 ${}
	 可使用以逗号隔开的列表形式：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo Fron{A,B,CBack
       FronBack FronBack FronBack
	 #+END_EXAMPLE

	 也可使用范围形式：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo Number_{1..5} #数字范围
       Number_1 Number_2 Number_3 Number_4 Number_5
       me@ubuntu16.04:~$ echo Number_{01..5} #长度补齐
       Number_01 Number_02 Number_03 Number_04 Number_05
       me@ubuntu16.04:~$ echo Number_{001..5}
       Number_001 Number_002 Number_003 Number_004 Number_005
       me@ubuntu16.04:~$ echo {Z..A} #字母范围
       Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
	 #+END_EXAMPLE

	 利用此功能同时生成多个文件夹：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mkdir Log
       me@ubuntu16.04:~$ cd Log/
       me@ubuntu16.04:~/Log$ mkdir {2016..2017{01..12}
       me@ubuntu16.04:~/Log$ lsp
	 #+END_EXAMPLE

**** 命令替换 ${命令}
	 将执行结果作为表达式输出：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$
       me@ubuntu16.04:~$ echo $(ls)
       Desktop Documents Downloads ...
	 #+END_EXAMPLE

	 列出cp对应程序的详细信息：
	 #+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ lsl $(which cp)
     rwxxx 1 root root 151024 2月  18 21:37 /bin/cp
	 #+END_EXAMPLE

	 结合管道使用：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ file $(lsd /usr/bin/* | grep zip)
	 #+END_EXAMPLE

*** 命令中的引号
	- echo命令的参数间，多余的空格被移除:
	  #+BEGIN_EXAMPLE
        me@ubuntu16.04:~$ echo this is a       test
        this is a test
	  #+END_EXAMPLE
	- $1变量未定义：
	  #+BEGIN_EXAMPLE
        me@ubuntu16.04:~$ echo The total is $100.00
        The total is 00.00
	  #+END_EXAMPLE

**** 双引号
	 将命令参数放入双引号中后，除参数膨胀、数学运算膨胀和命令替换膨胀
	 外的膨胀都失去意义；还有就是反引号和斜杠外的特殊字符外都失去意义。

	 可使用双引号操作有多余空格的文件名，如：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ lsl "two words.txt"
	 #+END_EXAMPLE
**** 单引号
	 去除所有特殊字符的意义。
**** 转义字符
	 转义字符需使用斜杠修饰。如：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo "The balance for user $USER is: \$5.00"
       The balance for user claudio is: $5.00
	 #+END_EXAMPLE

	 可用于操作特殊文件名：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mv bad\&filename good_filename
	 #+END_EXAMPLE

	 使用echo命令打印特殊字符时，需使用双引号（单引号中无特殊字符含义），
	 且配e参数使用：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo "hello\nword"
       hello\nword
       me@ubuntu16.04:~$ echoe "hello\nword"
       hello
       word
	 #+END_EXAMPLE

	 常用的转义字符有：
     | \a | beep            |
     | \b | Backspace       |
     | \n | Newline         |
     | \r | Carriage Return |
     | \t | Tab             |

** 快捷键
   快捷键基本上都与Emacs的快捷键相同。

*** 历史命令
	使用 *history* 命令可查看历史命令：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ history | grep /usr/bin
      ...
      88 lsl /usr/bin > loutput.txt
      ...
	#+END_EXAMPLE

	上例中的88为该命令在历史命令中的排序。可使用此序号重新执行：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ !88
      ...
	#+END_EXAMPLE

**** 搜索历史命令
	 - r：交互式搜索历史命令。
	 - j：粘贴搜索到的历史命令。
	 - g 或 c：退出交互式搜索历史命令。

**** 历史命令膨胀
     | !!       | 重复上一条命令                 |
     | !N       | 重复第N条历史命令              |
     | !String  | 重复上一条以String开头的命令   |
     | !?String | 重复上一条包含String的历史命令 |

** 权限

   - *id* ：显示用户身份信息
   - *chmod* ：更改文件模式（权限）
   - *unmask* ：设置文件默认权限
   - *su* ：更换用户运行shell
   - *sudo* ：更换用户执行命令
   - *chown* ：更改文件所有权
   - *chgrp* ：更改文件用户组所有权
   - *passwd* ：更改用户密码

*** 用户、用户组和全局权限
	尝试读取/etc/shadow文件。读取失败。原因为普通用户没有权限读取此文
	件：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ file /etc/shadow
      /etc/shadow: regular file, no read permission
      me@ubuntu16.04:~$ less /etc/shadow
      /etc/shadow: Permission denied
	#+END_EXAMPLE

	文件所有权限有3种形式：
	1. _用户_：如果文件/文件夹权限属于某用户，该用户可控制其访问权限。
	2. _用户组_：如果文件/文件夹属于用户组，用户组成员可访问。
	3. _全局_：如果文件/文件夹权限属于全局，所有用户可访问。

	当用户账号创建后，被赋予一个ID/uid，和一个主要用户组ID/gid，并可能
	属于某个用户组。 使用 *id* 命令可显示当前用户身份信息：

	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ id
      uid=1000(me) gid=1000(me)
      groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
      ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
	#+END_EXAMPLE

	以上信息中，用户账号存储在/etc/passwd文件中，用户组信息存储在
	/etc/group文件中。当用户账号创建后，以上2个文件随/etc/shadow文件
	（存储用户密码）更改。对各用户账号而言，/etc/passwd文件定义了该用
	户的登录名、uid、gid、账号真实名、home文件夹以及登陆shell。在
	/etc/passwd和/etc/group文件中，都定义了一个uid为0的的用户，便是超
	级用户。

*** 读、写和执行权限
	文件权限有3种：读、写和执行。使用 *lsl* 命令可查看：

	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ > foo.txt
      me@ubuntu16.04:~$ lsl foo.txt
     r 1 me me 0 8月  18 15:03 foo.txt
	#+END_EXAMPLE

	返回结果中，第一区域中的10个字符表示_文件属性_。其中第一个字母表示_文
	件类型_，以下为常见的文件类型：

    | - | 普通文件                                                           |
    | d | 文件夹                                                          |
    | l | 软链接，剩余的9个属性字符都为“rwxrwxrwx”，真实文件属性同其指向文件 |
    | c | 字符型文件                                                    |
    | b | 设备型文件                                                         |

	剩余的9个字符3个一组，分别代表用户权限、用户组权限和全局权限。
	“rwx”3个字符分别代表的含义：

	- r（只读）对文件而言，允许打开和读取；对文件夹而言，如果有执行属
      性，允许列出文件夹中的内容。

	- w（写入）允许文件被写入和清空，但不允许被重命名和删除，重命名和
      删除权限取决于所在文件夹的权限；对文件夹而言，允许在文件夹中创建
      和 删除文件，如果有执行属性，允许重命名其中的文件。

	- x（执行）允许文件被视作程序，并被执行。使用脚本语言编写的文件需
      设 置只读和执行权限；对文件夹而言，允许进入文件夹，如执行“cd
      directory”命令。

**** 使用chmod命令更改文件权限
	 只有拥有用户和超级用户才有权限使用chmod命令修改文件模式。有使用八
	 进制数和字符2中方式改变文件模式。

	 八进制数、二进制数和文件模式对比表：

     | 0 | 000 |     |
     | 1 | 001 |     |
     | 2 | 010 | x   |
     | 3 | 011 | wx  |
     | 4 | 100 | r   |
     | 5 | 101 | rx  |
     | 6 | 110 | rw  |
     | 7 | 111 | rwx |

	 使用符号修改文件模式时，其中的符号由3部分组成：目标用户、操作（添
	 加/删除）和权限。

     | u | “user”的缩写，表示文件拥有用户             |
     | g | 拥有用户组                                 |
     | o | “others”的缩写，除拥有用户和用户组的用户？ |
     | a | “all”的缩写，即“u”、“g”和“o”的结合         |

	 表示操作的符号有：
     | + | 添加权限                               |
     | - | 删除权限                               |
     | = | 删除所有已有权限，仅使用此处设置的权限 |

	 例：
	 - u+x_：为拥有用户添加执行权限。
	 - -x：删除拥有用户的执行权限。
	 - +x：为拥有用户、用户组和全局用户添加执行权限，等价于“a+x”。
	 - rw：删除除拥有用户和用户组外，用户的读和写权限。
	 - go=rw：将拥有用户组和全局用户的权限设置为读和写。如果拥有用户和
       其它用户有执行权限，删除。

**** 使用unmask命令设置文件默认权限
	 不跟任何参数，查看mask值：

	 例子：
	 #+BEGIN_EXAMPLE
       claudio@claudio:~$ umask #查看umask值
       0002
       claudio@claudio:~$ > foo.txt #新建文件
       claudio@claudio:~$ lsl foo.txt #查看其mask值
      r 1 claudio claudio 0 8月  20 13:33 foo.txt
       claudio@claudio:~$ umask 000 #重置mask值
       claudio@claudio:~$ rm foo.txt #删除该文件并新建
       claudio@claudio:~$ > foo.txt
       claudio@claudio:~$ lsl foo.txt #查看新建文件权限
      rrr 1 claudio claudio 0 8月  20 13:34 foo.txt
	 #+END_EXAMPLE

*** 添加用户和用户组
	http://blog.csdn.net/lele52141/article/details/6593840

	执行命令“adduser”根据提示设置密码和其它选项即可。

	"useradd"和“adduser”命令的区别在于，后者是前者的简单化版本，通过提
	示完成操作；前者每个参数需手动配置。

	“userdel”命令可删除用户。下面为其选项：
	- fforce：强制删除用户账号，即使是当前登陆账号也可。同时强制删除该
      用户的的home文件夹和mail spool，即使另一个用户也使用该home文 件
      夹，或者该mail spool不属于特定用户。

	- remove：删除该用户的home文件夹和mail spool，但文件系统中的相关文
      件需手动删除。

*** 更换用户
	更换用户有3种方法：
	1. 在图形界面更换用户
	2. 使用su命令
	3. 使用sudo命令

	其中后面两种可在当前shell实例（shell session，即打开的shell窗口）
	中操作，更方便。su命令更改当前用户，进入新的shell实例，或者使用新
	用户账号执行单个命令。

	使用sudo命令，可使管理员配置/etc/sudoers文件，指定某用户可执行的命
	令。

	sudo还是su命令的用法在不同版本（如ubuntu）中用法差异较大，有的版本两个
	命令都有。

	#+BEGIN_QUOTE
	进入新用户shell实例后，使用命令sudo时，会报错"\[用户名] is not in
	the sudoers file"。解决办法参考：
	<http://askubuntu.com/questions/151200/mmaiusernaminoithsudoerfile>

	即修改/etc/sudoers文件。编辑此文件后，如果写入内容有语法错误，会导致
	sudo命令不能正常运行，解决方法为 [执行pkexec visudo命令。参考：
	http://askubuntu.com/questions/73864/hotmodifinvalietsudoerfilithrowouaerroannoallowi
	#+END_QUOTE

	使用命令 *sudo -l* 可查看sudo可执行的命令。
**** chown改变文件所有权
	 - chown bob file：将文件所有权从当前用户转交到bob。
	 - chown bob:users file：将文件所有权从当前用户转交到bob，并将文件
       所有权用户组改为users
	 - chown :admins fils： 将文件所有权用户组改为admins，用户所有权不
       变
	 - chown bob:：将文件所有权从当前用户转交到bob，并将所有权用户组更
       改为用户bob的登陆用户组

*** 修改密码
	使用命令passwd修改密码。用法passwd [user]，如果不指定user，则修
	改当前用户密码。

*** 实践
** 进程
   - *ps* ：报告当前所有进程概况
   - *top* ：显示所有任务
   - *jobs* ：列出活动jobs
   - *bg* ：将一个job置于后台
   - *fg* ：将一个job置于前台
   - *kill* ：向单个进程发送信号（signal）
   - *killall* ：通过名字杀死进程
   - *shutdown* ：关闭或重启系统

*** 进程如何工作
	系统启动时，内核将多个自身活动作为进程初始化，并启动名为init.init
	的程序。init.init程序反过来运行一系列位于/etc目录下的shell脚本，利
	用这些脚本启动所有系统服务。这些服务中许多为后台程序（daemon
	programs），不提供用户界面。所以，即使系统启动后，没有登陆前，系统
	也在运行许多日常服务。

	利用父进程（parent process）和子进程（child process）的机制，一个
	程序可启动其它多个程序。

	为使整个系统更有条理，内核负责维护每个进程的信息。比如，每个进程都
	被赋值一个进程ID（process ID，PID）。赋值PID采用递增模式，其中init
	进程的PID始终为1。内核同时还跟踪分配给每个进程的内存，以及进程执行
	状态？。同文件一样，进程也有所有者和用户ID、有效用户ID等。

*** 查看进程
	查看进程最常用的命令为ps，其选项较多，下面介绍几种常用选项。

	不带任何参数，显示当前shell实例中打开的进程：
	#+BEGIN_EXAMPLE
      # 只用当前shell实例运行了ps一个进程
      me@ubuntu16.04:~$ ps
        PID TTY          TIME CMD
       5801 pts/20   00:00:00 bash
       6033 pts/20   00:00:00 ps
	#+END_EXAMPLE

	使用x选项查看当前用户所有的所有进程：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ ps x
        PID TTY      STAT   TIME COMMAND
       3021 ?        Ss     0:00 /lib/systemd/systemuser
       3022 ?        S      0:00 (spam)
       3028 ?        SLl    0:00 /usr/bin/gnomkeyrindaemodaemonizlogin
       3030 ?        Ss     0:00 /sbin/upstaruser
      ...
	#+END_EXAMPLE

	每列字符的含义为：
	- TTY：teletype，控制此进程的shell实例。“?”表示此进程不属于任何   |
      shell实例。

	- TIME：CPU处理此进程所耗时间。

	- STAT：“state”的缩写，表示该进程的状态。STAT中各字符含义：
	  - R：Running。表示此进程正在/准备运行。
	  - S：Sleeping。此进程暂时没有运行，在等待触发事件，如键盘输入等。
	  - D：Uninterruptible Sleep。正在等待I/O，如硬盘驱动。
	  - T：Stopped。已被发送指令停止。
	  - Z：死掉/“僵尸”（zombie）程序。此进程为已停止运行的子进程，但并
        没有被其父进程清除。
	  - <：高优先权进程。可为进程授权更高的权重，提供更多的CPU计算时间。
        此属性称为“谦让性（niceness）”。如果进程优先权越高，其“谦让性”
        就越低。因为其占用的更多的CPU计算时间，留给其它进程的时间就更
        少。
	  - N：低优先权进程。其它进程服务启动后，才开始占用CPU计算。

	使用aux选项查看更详细的进程信息：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ ps aux
      USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
      root         1  0.0  0.1 119936  6148 ?        Ss   05:56   0:01 /sbin/init spla
      root         2  0.0  0.0      0     0 ?        S    05:56   0:00 [kthreadd]
      root         3  0.0  0.0
      ...
	#+END_EXAMPLE

	其中各行的含义为：
    | USER  | 用户ID。该进程的拥有者                     |
    | %CPU  | CPU使用百分比                              |
    | %MEN  | 内存使用百分比                             |
    | VSZ   | 所占虚拟内存大小                           |
    | RSS   | 物理内存（RAM）使用量（单位kb）            |
    | START | 进程开启时间。如果超出24小时，以"天"为单位 |

*** 控制进程
**** 取消进程
	 使用<C-c>快捷键可取消进程。
**** 将进程放到后台
	 如需运行一个程序，但又希望继续使用当前shell实例，可将此程序置于后
	 台。

	 执行程序，并立即将其置于后台，在后添加“&”符号：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ xlogo &
       [1] 4980
       me@ubuntu16.04:~$
	 #+END_EXAMPLE

	 返回值[1] 4980为job控制信息，其中数字1（“[1]”）表示job数字，
	 “4980”表示PID。

	 执行ps命令，可看到置于后台的进程：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ ps
       PID TTY          TIME CMD
       4979 pts/12   00:00:00 bash
       4980 pts/12   00:00:00 xlogo
       4981 pts/12   00:00:00 psw
	 #+END_EXAMPLE

	 可使用job命令列出当前shell实例打开的jobs：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ jobs
       [1]+ Running      xlogo &
	 #+END_EXAMPLE

	 上面返回的含义为，只有一个job，编号为“1”，正在运行，且启动命令为
	 xlogo &。

**** 将进程从后台来回前台
	 命令行无法直接控制后台运行的程序，需使用fg命令将其拉回前台：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ jobs
       [1]+ Running      xlogo &
       me@ubuntu16.04:~$ fg %1w
	 #+END_EXAMPLE

	 其中“%1”为job膨胀，“1”为需要置于前台的job编号（jobspec）。

	 使用fg和bg命令时，如果jobs只有1个，可省略job编号膨胀（%1）。

**** 暂停进程
	 后台运行程序与暂停程序的区别在于，前者正常运行，后者不运行，但没
	 有关闭。命令为z。
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ xlogo
       # Ctrz
       [1]+ Stopped      xlogo
       me@ubuntu16.04:~$
	 #+END_EXAMPLE

	 此时如果缩放xlogo程序图形界面，“X”图标不会跟随缩放，证明此程序已
	 被暂停。

*** 信号
	使用kill命令可“杀死”进程：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ xlogo & # 启动xlogo程序，并置于后台
      [1] 6274 # 输出job编号和PID
      me@ubuntu16.04:~$ kill 6274 # 利用PID终止进程（也可使用job编号膨胀）
	#+END_EXAMPLE

	kill命令并不是真正“杀死”进程，而是向进程发送了信号（signal）。信号
	是操作系统与程序交流的方式之一。比如上面使用的快捷键Ctrc和Ctrz，
	当命令行接受这两个快捷键是，实际上是分别向前台程序发送了
	INT（Interrupt）和TSTP（Terminal Stop）信号。程序方面，一直都在“监
	听”信号，并对应用在自身的信号做出反应。

	基本用法：kill signal] PID...。如果不提供选项，默认发送
	TERM（Terminate）信号。常用信号有（括号内为等价数字代码）：

	- HUP（1）。Hangup，向程序支出控制命令行已经“挂起”。与关闭控制该程
      序的命令行效果一样？。该命令行内的前台程序接受此信号后，停止运行；
      对后台程序而言，实现重新初始化的效果。即，当后台程序接受此信号后，
      重启并重新读取其配置文件，Apache服务器就是使用如此使用HUP信号？。

	- INIT（2）。Interrupt，与使用<C-c>效果相同，通常会通知程序。

	- KILL（9）。,Kill，是个特殊信号。由于不同程序处理信号的方式不同，
      如完全忽视，此信号实际上并不直接发送给目标程序，而是通过内核立即
      终止进程。用此方式终止的进程，无法“clean up”和保存内容？。因此
      KILL信号应当在所有终止信号尝试失败时才使用。

	- TERM（15）。Terminate，**kill命令使用的默认信号**。如果某个程序
      依然“活跃（alive）”，将被终止。

	- CONT（18）。Continue，恢复接收STOP信号后的进程。与使用
      <C-z>快捷键，在将其置于后台效果相同。

	- STOP（19）。Stop，使进程暂停，效果如<C-z>快捷键。同KILL信号一样，
      并不直接发送给目标进程，所以无法忽略。

	例：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ xlogo & # 将程序置于后台
      [1] 123456
      me@ubuntu16.04:~$ kill1 123456 # 发送HUP信号
      claudio@claudio:~$ # 按回车
      [1]+  Hangup                  xlogo # 显示接收信号后的信息
	#+END_EXAMPLE

	可使用数字、名称和带“SIG”前缀的名称发送信号。下面3种方式等价：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ xlogo &
      [1] 123456
      me@ubuntu16.04:~$ kill1 123456 # 使用数字
      me@ubuntu16.04:~$ xlogo &
      [1] 123456
      me@ubuntu16.04:~$ killHUP 123456 # 使用名称
      me@ubuntu16.04:~$ xlogo &
      [1] 123456
      me@ubuntu16.04:~$ killSIGHUP 123456 # 使用带前缀的名称
	#+END_EXAMPLE

	下面列出一些系统常用的信号及其含义：
	- QUIT（3）。Quit，放弃。

	- SEGV（11）。Segmentation Voilation，如果某程序非法使用内存，即尝
      试在不允许的文件写入数据时发送此信号。

	- TSTP（20）。Terminal Stop。当<C-z>按下时命令行发出的信号。不想
      STOP信号，程序接收到TSTP信号后，可选择忽略。

	- WINCH（28）。Window Change，当程序所在窗口缩放时，系统发出的信号。
      如top和less程序，接受到此信号后更改行为，以使用当前窗口大小。

	查看所有kill可接受的选项使用l”选项：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ kill -l
	#+END_EXAMPLE

**** killall 向多个进程同时发送信号
	 使用killall命令可以同时向多个进程（可指定所属用户或某类），基本用
	 法为killall u user] signal] name...。

	 运行多个xlogo实例后，使用killall命令通知发送终止信号：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ xlogo &
       [1] 7788
       me@ubuntu16.04:~$ xlogo &
       [2] 7789
       me@ubuntu16.04:~$ killall xlogo
       me@ubuntu16.04:~$ # 再次按下回车键才能显示结果
       [1  Terminated              xlogo
       [2]+  Terminated              xlogo
	 #+END_EXAMPLE

	 与kill命令相同，向所有权不为当前用户的进程发送信号，需要超级权限。

*** 关闭系统
	有4个命令可关闭系统：halt、poweroff、reboot和shutdown，其
	中前3个为按其名称就可知道其功能，且安装它们的手册描述，都仅为向后
	兼容保留的命令，不如shutdown应用灵活（可实现halt、poweroff、
	reboot和shutdown功能，还可指定时间）。

*** 其它常用进程命令
	检测进程是系统管理的重要任务，有许多相关命令，下面介绍4个：
	- pstree：以树状形式列出进程，突出父进程和子进程关系。
	- vmstat：显示系统资源使用概况，包括内存、交换分区和硬盘I/O（disk
      I/O）。如需实时更新，可在后面跟上间隔描述，如vmstat 5，结束使
      用<C-c>命令。
	- xload：使用图像界面实时绘制系统负载。
	- tload：与xload功能相同，不过是在命令行绘制。

* Configuration And The Environment
** 环境
   每一个shell实例都有一个对应环境（enviroment）。各程序使用此环境中的
   数据侦测系统配置。尽管绝大多数程序使用配置文件储存自身设置，但还是
   有一些依赖环境。

   - *printenv* ：打印部分或全部环境数据
   - *set* ：显示shell选项
   - *export* ：向执行程序导入环境数据？
   - *alias* ：使用命令创建别名
*** 何为环境
	环境中，shell存储2类数据：环境变量和shell变量。bash负责存储shell变
	量，除此之外的为环境变量。除变量外，shell还存储别名和shell函数。
**** 检测环境
	 使用shell内置函数set和printenv程序可查看环境中存储的数据，前者显
	 示shell和环境变量，后者只显示环境变量。

	 查看环境变量，结合less命令：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ printenv | less
	 #+END_EXAMPLE

	 使用printenv查看单个变量值：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ printenv USER
	 #+END_EXAMPLE

	 使用set函数查看shell变量、环境变量和shell函数，结果通常按字母排序：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ set | less
	 #+END_EXAMPLE

	 set和printenv都不显示别名，需使用alias命令：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ alias
	 #+END_EXAMPLE

**** 变量举例
	 下列变量因系统差别较大，仅以本机为例：

	 - DISPLAY：如果为图像环境，返回值为显示实例名称，通常为":0"，即X
       server生成的第一个显示实例。
	 - SHELL：shell程序名称。
	 - HOME：home文件路径。
	 - LANG：本机语言设置。
	 - PATH：执行程序时，对应搜索路径，用冒号隔开。
	 - PS1：Prompt String 1。shell对话字符串。
	 - PWD：当前目录。
	 - TERM：命令行类型。类Unix系统支持多种命令行协议；此变量用于设置
       本机命令行模拟器。
	 - USER：用户名。

*** 环境如何建立

	当登陆系统时，basg程序启动，读取配置脚本（_startup files_，定义所
	有用户共享的环境配置）。随后读取home文件夹内的启动文件，配置各用户
	单独环境。读取顺序取决于启用何种shell实例：登陆实例和非登陆实例。

	登陆实例需输入用户名和密码，如虚拟机命令行；非登陆实例通常在图形界
	面环境中使用。

	登陆实例读取下列一个或多个启动文件：
	- /etc/profile：所有用户共享的全局配置脚本。
	- ~/.bash_profile：用户私有启动文件。可用于扩展或重置全局配置。
	- ~/.bash_login：如果不能找到~/.bash_profile文件，bash尝试使用此文
      件代替。
	- ~/.profile：如果~/.bash_profile和~/.bash_login都未找到，bash尝试
      使用此文件代替。Debian类系统如Ubuntu默认使用此文件。

	非登陆实例使用下例2个文件多为启动文件：
	- /etc/bash.bashrc：所有用户共享的全局配置脚本。
	- ~/.bashrc：用户私有启动文件。可用于扩展或重置全局配置。

	除读取上述启动文件外，非登陆实例通常还从其父进程（一般为登陆实例）
	继承环境配置。

	对普通用户而言，~/.bashrc文件始终需读取，所以是最重要的文件。

*** 简单分析启动文件
	下面是~/.profile文件中的内容（Ubuntu）：
	#+BEGIN_EXAMPLE
      # ~/.profile: executed by the command interpreter for login shells.
      # This file is not read by bash(1), if ~/.bash_profile or ~/.bash_login
      # exists.
      # see /usr/share/doc/bash/examples/startufiles for examples.
      # the files are located in the basdoc package.

      # the default umask is set in /etc/profile; for setting the umask
      # for ssh logins, install and configure the libpaumask package.
      #umask 022

      # if running bash
      if [n "$BASH_VERSION" ]; then
          # include .bashrc if it exists
          if [f "$HOME/.bashrc" ]; then
          . "$HOME/.bashrc"
          fi
      fi

      # set PATH so it includes user's private bin directories
      PATH="$HOME/bin:$HOME/.local/bin:$PATH"
	#+END_EXAMPLE

	- #：注释语句
	- if：条件语句的含义为：
	- PATH=...：以ls命令为例，当使用ls命令时，不是直接搜索并执行
      /bin/ls程序，而是根据PATH参数来计算。

*** 修改环境

	*基本规则，如需在PATH中增加文件夹，或者定义额外环境变量，修
	改.bash_profile文件（或等价文件，如Ubuntu中的.profile文件）；其它
	所有修改，更改.bashrc文件。*

	*修改重要文件时，最好先为其保留副本，以免造成系统崩溃。如修
	改.bashrc文件，最好为其新建副本".bashrc.bak"，后缀名易识别即可。*

	备份.bashrc文件：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ cp .bashrc .bashrc.bak
	#+END_EXAMPLE

	在.bashrc文件末添加下列内容：
	#+BEGIN_SRC shelscript
      # 自己修改的内容
      # 只显示隐藏文件和文件夹的别名
      alias l.='lsdF .[!.]color=auto'
	#+END_SRC

	修改后.bashrc文件只有在新的shell实例中生效，如需使其在当前实例中
	生效，可使用source命令：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ source .bashrc
	#+END_EXAMPLE

** vim简介
** 定制shell提示
*** 解析提示字符串
	查看一下命令行提示格式：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ echo $PS1
      # 各系统上差异较大，这里使用简单举例
      \u@\h \W \$
	#+END_EXAMPLE

	PS1变量为"Prompt String 1"的缩写。

	看起来很怪异，实际上大部分是一些特殊字符：

    | \a | ANCII警报。计算机解析到此字符串时发出警报（本机测试失败）。        |
    | \d | 期。格式为"周几 月份 号数"。如"四 8月 25"。                        |
    | \h | 除后缀域名后的，本机主机名。                                       |
    | \H | 整主机名。                                                         |
    | \j | 前shell实例中已有的job数量。                                       |
    | \l | 前命令行设备名称。一般为"0"。                                      |
    | \n | 行字符。                                                           |
    | \r | 车字符。                                                           |
    | \s | Shell程序的名称。一般为"bash"。                                    |
    | \t | 前时间，格式为"时:分:秒"，24小时格式。                             |
    | \T | 前时间，12小时格式。                                               |
    | \@ | 前时间，12小时格式，显示"上午"/"下午"。                            |
    | \A | 前时间，24小时格式，不显示秒数，"时:分"。                          |
    | \u | 前用户名。                                                         |
    | \v | Shell版本号。                                                      |
    | \V | Shell版本和发行号。                                                |
    | \w | 前目录。                                                           |
    | \W | 前目录的最后一部分。                                               |
    | !  | 前命令在命令历史记录里的排序。                                     |
    | #  | 前shell实例中已输入的命令数量                                      |
    | \$ | 果是超级用户显示"$"，否则显示"#"。                                 |
    | [  | 示一个或多个非打印控制字符串的开始。这类字符串可控制光标和颜色等。 |
    | ]  | 一个或多个非打印控制字符串的开始。                                 |

*** 尝试改变提示
	_命令行中的修改只在当前shell实例中有效，请放心使用。_

	将PS1变量缓存，及恢复：
	#+BEGIN_EXAMPLE
      # 缓存到变量ps1_old
      me@ubuntu16.04:~$ ps1_old="$PS1"
      # 查看是否缓存成功
      me@ubuntu16.04:~$ echo $ps1_old
      # 更改PS1变量，立即生效
      me@ubuntu16.04:~$ PS1="....."
      .........
      # 恢复PS1变量默认值
      me@ubuntu16.04:~$ PS1="$ps1_old"
	#+END_EXAMPLE

	使用每条命令开始执行时发出警报（本机测试失败）：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\a\]\$ "
	#+END_EXAMPLE
	使用[和]是因为\a字符并不打印出来。

	使提示信息包含主机名和当前时间：
	#+BEGIN_EXAMPLE
      $ PS1="\A \h \$ "
      16:18 ubuntu16.04 $
	#+END_EXAMPLE

*** 添加颜色
	绝大多数命令行模拟程序都使用非打印字符控制字符属性（如颜色、粗细
	等），以及光标位置。

	将ANSI转义码（ANSI escape code），嵌入到命令模拟器提示字符串中，即
	可实现对命令行模拟器发送指令的功能。ANSI转义码为非打印字符，需置于
	[和]内。

	ANSI转义码以8进制数"033"开头，后为[，后为属性字符（可选），最后为
	指令字符。

	以\033[0;30m]为例，其中\[和;间的0为属性字符，可取值为：
    | 0 | 正常。                 |
    | 1 | 加粗。                 |
    | 4 | 下划线。               |
    | 5 | 闪烁（通常已被禁用）。 |
    | 7 | 反转（inverse）。      |

	下列为表示光标移动的ANSI转义码：
    | 033[0;30m | 黑   | 033[1;30m | 深灰   |
    | 033[0;31m | 红   | 033[1;31m | 浅红   |
    | 033[0;32m | 绿   | 033[1;32m | 浅绿   |
    | 033[0;33m | 棕   | 033[1;33m | 黄     |
    | 033[0;34m | 蓝   | 033[1;34m | 浅蓝   |
    | 033[0;35m | 粉   | 033[1;35m | 浅粉   |
    | 033[0;36m | 蓝绿 | 033[1;36m | 浅蓝绿 |
    | 033[0;37m | 灰白 | 033[1;37m | 白     |

	将提示字符串颜色设置为绿色：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\033[0;32m]\]\A \h \$ "
      ...
	#+END_EXAMPLE

	通过上述设置后，当输入命令时也是设置的颜色。模拟器遇见ANSI转义码时
	开始转换颜色，还原原来颜色需使用转义码\033[0m：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\033[0;32m]\]\A \h \$\[\003[0m\] "
      ...
	#+END_EXAMPLE

	下表为常用背景颜色ANSI转义码（不支持加粗属性，也使用\033[0m还原）：
    | 033[0;40m] | 黑 | 033[0;44m] | 蓝   |
    | 033[0;41m] | 红 | 033[0;45m] | 粉   |
    | 033[0;42m] | 绿 | 033[0;46m] | 蓝绿 |
    | 033[0;43m] | 棕 | 033[0;47m] | 灰白 |

	将提示字符串背景色设置为绿色：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\033[0;42m\]\A \h \$\[\033[0;0m\] "
	#+END_EXAMPLE

*** 移动光标
	以PS1 =
	"\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\\]<\u@\h\W>\$"
	，在命令行顶部显示红底黄字的当前时间，为例：

	- \[：标记非打印字符开始。帮助bash计算可见字符串长度。
	- \033[s：缓存当前光标位置。_一些命令行模拟器不能识别此字符。
	- \033[0;0H：将光标置于第一行，第一列。
	- \033[0;41m：将背景色设置为红色。
	- \033[K：从光标处清除到行尾。相当于换行作用，使之前的设置占满整
	  行；_光标位置并不变化_。
	- \033[1;33m：将文本颜色设置为黄色。
	- \t：显示当前时间。虽然这是一个打印字符，为了不使bash计算提示字符
      串实际长度时，将其计算在内，所以仍然包裹在\[\]内。
	- 033m[0m：还原文本和背景色。
	- \033[u：还原已缓存的光标位置。
	- \]：结束非打印转义字符。
	- <\u@\h \W>\$：真正的提示字符串。

	下列为表示光标移动的ANSI转义码：
    | 033[l;cH | 移至l行c列                   |
    | 033[nA   | 向上移动n行                  |
    | 033[nB   | 向下移动n行                  |
    | 033[nC   | 向前移动n个字符位置          |
    | 033[nD   | 向后移动n个字符位置          |
    | 033[2J   | 清屏，并移至左上角（0行0列） |
    | 033[k    | 从当前位置清除到行末         |
    | 033[s    | 缓存光标位置                 |
    | 033[u    | 还原光标位置                 |

*** 保存
	为使设置永久生效，在.bashrc 文件中添加在命令行中一样的复制语句即可：

	#+BEGIN_EXAMPLE
      PS1="\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ "
	#+END_EXAMPLE

* Common Tasks And Essential Tools
** 包管理
   一个linux版本（disttribution）的好坏，取决于 *包管理系统* 和 *社区
   活跃程度* ，因为软件更替速度相当快。

   包管理是指安装和维护软件的方法。如今，基本上所有包都可以从不同版本
   的发行方获取。早期，安装软件下载并编译 *源代码*，此方法只是不太方便，
   需获取系统更高的控制权？。
*** 包管理系统
	不同发行版本有自己的包管理系统，且互不兼容。除Gentoo、 Slackware和
	Arch等外，绝大多数版本分为了2大阵营：Debian的".deb"和Red Hat的
	".rpm"。

    | Debaian风格（.deb）  | Debain、Ubuntu、Linux Mint、Raspbian               |
    | Read Hat风格（.rpm） | Fedora、CentOS、Red Hat Enterprise Linux、OpenSUSE |

*** 包管理系统如何工作
	Linux所有的安装包都可通过网路获取。存在方式有2中：绝大多数由版本供
	应商以_包文件_的形式提供；其余部分为需手动安装的源代码。

*** 常用的包管理任务
**** 从项目中寻找包
	 使用高级包管理工具可通过包名和关键字，在仓库元数据中搜索对应包。

	 包搜索命令：
     | Debian  | apt search /名称或关键字/ |
     | Red Hat | yum search /名称或关键字/ |

	 比如在Ubuntu中搜索"emacs"编辑器：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ apt search emacsw
	 #+END_EXAMPLE

**** 从项目中安装包
	 使用高级包管理工具，可从仓库下载一个包并安装，同时还可解决依赖问
	 题。

	 包安装命令：

	 | Debian  | apt install /名称或关键字/ |
	 | Red Hat | yum install /名称或关键字/ |

	 比如在Ubuntu中安装"emacs"编辑器：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ apt install emacs
	 #+END_EXAMPLE

**** 用文件安装包
	 如果是下载的源码，需使用低级包管理工具安装。但不能自动解决依赖问
	 题，依赖缺失时会报错。低级包管理工具对应命令：

     | Debain  | dpkg --install /已下载的文件名/ |
     | Red Hat | rmp -i /已下载的文件名/         |

	 以Ubuntu安装搜狗拼音为例
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ dpkg --install sogoupinyin_2.0.0.0078_amd64.deb
	 #+END_EXAMPLE

**** 卸载包
	 高级和低级包管理工具都可卸载包。原则为高级工具卸载高级工具安装的
	 包，低级工具卸载低级工具安装的包。

     | Debain  | apt remove _包名_ | dpkg --remove _包名_ |
     | Red Hat | yum erase _包名_  | ?                    |

	 卸载emacs：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ apt remove emacs
	 #+END_EXAMPLE

**** 更新包
	 包管理工具最重要的任务就是跟新所有安装包，只需一个命令就可实现：

     | Debian   | apt update;apt upgrade |
     | Red Hate | yum upgrade            |

	 如果是使用低级包管理工具安装的包，Debian中只有重新安装，实现更新；
	 Red Hat中则可使用`rpm`命令的"-U"选项：

     | Debian  | dpkg --install /需要跟新的包对应的新下载文件/ |
     | Red Hat | rpm -U /需要跟新的包对应的新下载文件/         |

**** 列出所有已安装包
     | Debian  | dpkg --list |
     | Red Hat | rpm -qa     |
**** 查看一个包是否已安装
     | Debian  | dpkg --status /包名/ |
     | Red Hat | rpm -q /包名/        |

**** 查看一个已安装包的描述信息
     | Debian  | apt-cache show _包名_ |
     | Red Hat | yum info _包名_       |

**** 查看已安装包的安装文件
	 查看包安装后，写入了哪些文件？：

     | Debian  | dpkg --search _包名/关键字_ |
     | Red Hat | rpm -df _包名/关键字_       |

** 存储设备
   以往章节都是以文件为单位讨论数据处理，本节以设备为单位讨论数据处理。
   不管是物理存储设备，如硬盘和网络连接存储（nerwork storage）；还是虚
   拟存储设备，如磁盘阵列（Redundant Arrays of Independent Disks，RAID）
   和逻辑卷管理（Logical Volume Manager，LVM），Linux都有出色的处理能
   力。

   学习本节需要的设备有可擦写光盘（CD-RW）、U盘（usb flash drive）和软
   盘（floppy disk）。

   - *mount* ：挂载文件系统。
   - *umount* ：对文件系统解除挂载
   - *fsck* ：检测和修复文件系统
   - *fdisk* ：磁盘分区表操作（Partition table manipulator）
   - *mkfs* ：创建文件系统
   - *dd* ：将设备型文件直接写入设备
   - *fdformat* ：格式化软盘
   - *genisoimage（mkisofs）* ：创建一个ISO镜像文件
   - *wodim（cdrecord）* ：将数据写入存储介质（optical storage media）
   - *md5sum* ：计算MD5值

*** 挂载和取消挂载存储设备
	操作存储设备，首先需将其添加到文件系统树上，成为操作系统的一部分。
	此过程即称为“挂载”。

	在桌面系统上，存储设备会自带挂载。以Ubuntu16.04为例，U盘和光盘会自
	带挂载到“/media/用户名”目录下，安卓手机会挂载到“/run/user/用户名ID
	（一般为1000）/gvfs”目录下。 _在服务器上，则需手动挂载。_

	/etc/fstab（“file system tabe”的缩写）文件中包含所有系统启动时就挂
	载的设备（一般为硬盘分区）：
	#+BEGIN_EXAMPLE
      # <file system> <mount point>   <type>  <options>       <dump>  <pass>
      # / was on /dev/sda1 during installation
      UUID=2b59c6b3-ced1-4535-a730-095092943a66 /               ext4    errors=remount-ro 0       1
      # /home was on /dev/sda6 during installation
      UUID=796f3a21-35bd-48c8-9b53-bb6214a0a50b /home           ext4    defaults        0       2
      # swap was on /dev/sda5 during installation
      UUID=34cc34a6-139d-45da-aea8-94924140285e none            swap    sw              0       0
	#+END_EXAMPLE

	各列的含义分别为：

	1. 设备名（文件系统，file system）。传统情况下为系统中物理设备的
       真实名字，如dev/sda1（第一个硬盘上的第一个分区）。不过现今一般
       使用标签（label）表示，标签可以是纯文本或UUID（如上）。当设备
       连接系统时，系统读取此标签。
	2. 挂载点（mount point）。设备在系统文件树上对应的位置。
	3. 文件类型（type）。绝大多数Linux系统使用ext4（第四代扩展文件系
       统，Fourth Extended File System），不过也支持FAT16 (msdos)、
       FAT32 (vfat)、 NTFS (ntfs)和CD-ROM (iso9660)等。
	4. 挂载选项（options）。文件系统可使用多种挂载选项。比如，可挂载为
       只读，防止在内执行程序？（可提高移动设备的安全性）。
	5. 备份（dump）。使用dump命令备份时，指定是否接受备份，以及何时备
       份。
	6. 检测/修复（pass）。使用fsck检测和修复时的执行顺序。

**** 查看已挂载的文件系统
	 使用mount命令，不带任何参数，可查看当前已挂载的所有文件系统：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mount
       /dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)
       securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relat
       ime)
       tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
       tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
       tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
       ...
       /dev/sdb1 on /media/me/disk type vfat (rw,nosuid,nodev,relatime,uid=1000,gid=1000,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)
	 #+END_EXAMPLE

	 输出内容的格式为：“设备名 on 挂载点 type 文件类型（挂载选项）”。
	 比如第一行的含义为，/dev/sda1设备挂载到根目录上，文件格式为ext4，
	 可读可写（“rw”）。

	 为测试，插入一张可读写光盘后，重新执行mount命令会新增如下内容：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mount | less
       ...
       /dev/sr0 on /media/me/e-STUDIO Client type iso9660 (ro,nosuid,nodev,relatime,uid=1000,gid=1000,iocharset=utf8,mode=0400,dmode=0500,uhelper=udisks2)
       ...
	 #+END_EXAMPLE

	 上例表示，光盘设备在系统中的设备名为/dev/sr0，挂载点为
	 /media/me/e-STUDIO Client。

	 取消挂载光盘：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ ls /media/me #可见光盘中内容
       e-STUDIO Client
       me@ubuntu16.04:~$ sudo umount /dev/sr0
       me@ubuntu16.04:~$ ls /media/me
       # 表示光盘的文件夹消失，表示取消挂载成功
	 #+END_EXAMPLE

	 为光盘新建一个挂载点，使用-t选项表示文件类型：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ sudo mkdir /mnt/cdrom # 新建文件夹
       # 将光盘挂载到新建的文件夹上，iso9660为光盘的文件格式
       me@ubuntu16.04:~$ sudo mount -t iso9660 /dev/sr0 /mnt/cdrom
       me@ubuntu16.04:~$ ls /mnt/cdrom
       ... #出现光盘内容，表示挂载成功
       me@ubuntu16.04:~$ sudo umount /dev/sr0 #再次取消挂载
       me@ubuntu16.04:~$ ls /mnt/cdrom
       # 无任何内容，取消挂载成功
	 #+END_EXAMPLE

**** 判断设备名称
	 在桌面系统中，设备自动挂载后可使用mount命令查看其在系统系统中的名
	 称；但是，在不支持自动挂载的环境中（如服务器），则需要通过查看
	 /dev文件夹来确定设备在系统中对应的名称。/dev文件夹包含了系统中所
	 有设备（为何安卓手机设备不包含？）。

	 不同类型设备有特定的命名规则：

	 - fd*：软盘。

	 - hd*：老式系统中的IDE硬盘（IDE即Integrated Drive Electronics）。
       尤其是指主板有2个IED管道/接口（channels/connectors），每个接口
       都由一 根有2个附着点的线路链接的硬盘？？。线路上的第一个硬盘称
       为主设备， 第二个称为奴设备。命名规则为，/dev/hda表示第一个管道
       上的主设备， /dev/hdb表示第一个管道上的奴设备；/dev/hdc表示第二
       个管道上的主设备。 以此类推。名称后所跟数字表示在设备上的分区号，
       比如/dev/hda1表示第 一个硬盘上的第一个分区，/dev/hda表示整个硬
       盘。

	 - /dev/lp*：打印机。

	 - /dev/sd_：SCSI硬盘（是采用SCSI接口的硬盘，SCSI是Small Computer
       System Interface”小型计算机系统接口“”的缩写，使用50针接口，外观
       和普通硬盘接口有些相似）。在现代Linux系统中，内核将所有
       disk-like设备（包括PATA/SATA硬盘、U盘、如mp3/4这样的USB大型存储
       设备和数码相机）都视为SCSI硬盘。命名的后半部分和/dev/hd_设备规
       则相同。

	 - /dev/sr*：光驱（CD/DVD读取机/刻录机）。

	 在不自动挂载移动设备的环境中，可使用tail命令实时查看系统日志来判
	 断设备名称：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ sudo tail -f /var/log/syslog
	 #+END_EXAMPLE

	 以插入U盘为例，当插入U盘后，会出现类似如下的类容：
	 #+BEGIN_EXAMPLE
       ...
       Aug 27 21:27:42 me kernel: [14505.508766]  sdb: sdb1
       Aug 27 21:27:42 me kernel: [14505.509862] sd 8:0:0:0: [sdb] Attached SCSI removable disk
       ...
	 #+END_EXAMPLE

	 通过上面结果可知，U盘对应的系统设备名称为/dev/sdb，/dev/sdb1为其
	 第一分区。

	 得知设备在系统上对应的名称后，就可将其挂载到文件树上：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ sudo mkdir /mnt/flash
       me@ubuntu16.04:~$ sudo mount /dev/sdb1 /mnt/flash
       me@ubuntu16.04:~$ df -h #使用df命令查看所有文件系统使用情况
       ...
       /dev/sdb1        14G  548M   14G   4% /media/me/disk
       # /dev/sr0        594M  594M     0 100% /media/me/e-STUDIO Client
	 #+END_EXAMPLE

	 *重启前，挂载的设备会一直有效。*

*** 创建新的文件系统
	比如要将U盘原有的FAT32文件系统格式化为Linux本地文件系统，需2步：
	1. （可选）修改分区。
	2. 在U盘上创建新的空文件系统。

**** 使用fdisk命令对设备分区
	 以对U盘分区为例。首先需去挂载：
	 #+BEGIN_EXAMPLE
       sudo unmount /dev/sdb1
       sudo fdisk /dev/sdb
	 #+END_EXAMPLE

	 *注意：使用fdisk操作设备时需使用整个设备，而不是单个分区。*

	 程序启动后进入交换页面：
	 #+BEGIN_EXAMPLE
       Command (m for help):
	 #+END_EXAMPLE

	 使用m命令可查看所有可执行的命令：
     | a |                                             |
     | b |                                             |
     | c |                                             |
     | d | 删除一个分区                                |
     | l | 列出所有有效的分区文件系统                  |
     | m |                                             |
     | n | 新建一个分区                                |
     | o |                                             |
     | p | 打印当前的分区情况                          |
     | q | 不执行修改，退出                            |
     | s |                                             |
     | t | 改变设备的文件系统，从l命令中获取的ID中选择 |
     | u |                                             |
     | v |                                             |
     | w | 确认更改，写入，并退出                      |
     | x |                                             |

	 首先使用p命令查看当前的分区情况：
	 #+BEGIN_EXAMPLE
       Disk /dev/sdb: 16 MB, 16006656 bytes
       1 heads, 31 sectors/track, 1008 cylinders
       Units = cylinders of 31 * 512 = 15872 bytes
             Device      Boot   Start    End     Blocks    Id  System
          /dev/sdb1             2        1008    15608+    b   W95 FAT32
	 #+END_EXAMPLE

	 可见，U盘设备为16MB，有1个分区（/dev/sdb1），使用了1008个扇面
	 （cylinders）中的1006个（End - Start）。Id项显示的为格式化系统类
	 型对应的编号（b），System则是其相应的名称。

	 下面通过l命令查看可选格式化类型。

	 使用t命令开始修改，选中83对应的Linux文件系统，最后执行w命令确认并
	 退出。（如果不使用w命令，可使用q命令放弃所有修改并退出）
**** 使用mksf创建新的文件系统
	 对设备分区后，可使用mksf命令为各分区创建新的文件系统。使用-t参数
	 指定文件系统类型，如：
	 #+BEGIN_EXAMPLE
       sudo mkfs -t ext4 /dev/sdb1
	 #+END_EXAMPLE

	 如需改回原有的FAT32文件系统，可使用vfat参数值指定：
	 #+BEGIN_EXAMPLE
       sudo mkfs -t vfat /dev/sdb1
	 #+END_EXAMPLE

*** 测试和修复文件系统
	系统启动时，会自动执行fsck命令检查文件（对应设备），文件/etc/fstab
	中最后一项为检查顺序。如果有错误，系统会停止启动。

	此外fsck命令还可用于检查指定设备：
	#+BEGIN_EXAMPLE
      sudo fsck /dev/sdb1
	#+END_EXAMPLE

*** 格式化软盘
*** 直接从设备上写入和读取数据
	需使用dd命令，一般格式为：
	#+BEGIN_EXAMPLE
      dd if=input_file of=output_file [bs=block_size [count=blocks]]
	#+END_EXAMPLE

	*dd命令会提前清空目标文件中的所有内容。*

	比如有2个U盘，挂载点分别为/dev/sdb和dev/sdc，将前一个U盘中的内容写
	入后一个的命令为：
	#+BEGIN_EXAMPLE
      dd if=/dev/sdb of=/dev/sdc
	#+END_EXAMPLE

	或者可以将设备中的所有文件复制到本地：
	#+BEGIN_EXAMPLE
      dd if=/dev/sdb of=flash_drive.img
	#+END_EXAMPLE

*** 创建CD_ROM镜像文件
	向光盘写入镜像文件分2步：
	1. 创建与光盘文件系统相同的镜像文件。
	2. 向光盘写入已有的镜像文件。

**** 利用光盘创建镜像文件
	 将光盘拷贝到本地备用，以将Ubuntu镜像光盘为例：
	 #+BEGIN_EXAMPLE
       dd if=/dev/cdrom of=ubuntu.iso
	 #+END_EXAMPLE

**** 利用本地文件创建镜像文件
	 以将文件夹~/cd-rom-files中的文件夹复制到镜像文件cd-rom.iso为例：
	 #+BEGIN_EXAMPLE
       genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
	 #+END_EXAMPLE

*** 写入CD_ROM镜像文件
	有了镜像文件后，就可将其写入光盘等介质。
**** 直接挂载镜像文件
	 结合"-o loop"参数（以及-t iso9660参数）可将本地镜像文件像设备一样
	 挂载到文件树上，以已有的image.iso镜像文件为例：
	 #+BEGIN_EXAMPLE
       mkdir /mnt/iso_image
       mount -t iso9660 -o loop image.iso /mnt/iso_image
	 #+END_EXAMPLE

**** 清空可重写的CD-ROM
	 使用wodim命令可清空一个可写的CD-ROM，blank参数表示执行速度：
	 #+BEGIN_EXAMPLE
       wodim dev=/dev/cdrw blank=fast
	 #+END_EXAMPLE
**** 写入镜像文件
	 写入镜像文件也是使用wodim命令：
	 #+BEGIN_EXAMPLE
       wodim dev=/dev/cdrw image.iso
	 #+END_EXAMPLE

	 除dev参数外，还可设置-v参数提供verbose输出，以及用于商业保护的-dao参
	 数，还有-tao参数（track-at-once）。

*** md5sum
	使用md5sum命令可查看iso文件和光盘介质的大小验证值：

	检查iso文件的值：
	#+BEGIN_EXAMPLE
      md5sum image.iso
      34e354760f9bb7fbf85c96f6a3f94ece image.iso
	#+END_EXAMPLE

	检查光盘介质的值：
	#+BEGIN_EXAMPLE
      md5sum /dev/cdrom
      34e354760f9bb7fbf85c96f6a3f94ece /dev/cdrom
	#+END_EXAMPLE

** 网络
   - *ping* ：向一个网络主机发生ICMP ECHO_REQUEST。
   - *traceroute* ：
   - *ip* ：
   - *netstat* ：
   - *ftp* ：传输网络文件。
   - *wget* ：非交互式网络下载工具。
   - *ssh* ：OpenSSH SSH客户端（远程登录程序）。

*** 网络检查和侦测
**** ping
	 使用ping命令可向指定主机发送ICMP ECHO_REQUEST特殊请求（有的服务器
	 可通过配置忽视此请求）。

	 #+BEGIN_EXAMPLE
       ping bing.com
	 #+END_EXAMPLE

	 使用C-c结束命令后，如果网络正常，会显示0% packet loss。

**** traceroute
	 显示访问指定主机需经过的网路：

	 #+BEGIN_EXAMPLE
       traceroute bing.com
       traceroute to bing.com (13.107.21.200), 30 hops max, 60 byte packets
           1  gateway (192.168.43.1)  2.094 ms  2.061 ms  2.096 ms
           2  * 10.231.0.1 (10.231.0.1)  133.445 ms  133.570 ms
           3  192.168.183.209 (192.168.183.209)  144.619 ms  144.832 ms  144.783 ms
           4  192.168.52.245 (192.168.52.245)  144.760 ms  144.735 ms  144.718 ms
           5  183.221.32.13 (183.221.32.13)  146.757 ms  146.897 ms  146.896 ms
	 #+END_EXAMPLE

	 从上例可看出，本机访问bing.com需经过5个网路。如果路由提供身份信息，
	 可见其主机名、IP地址及性能数据；如果不提供则为星号。

**** ip
	 ip命令是一个多功能的网路配置工具，可完全利用现代Linux内核的网络功
	 能。（是已废弃命令ifconfig的替代）

	 如检查网络接口和"路由表（routing table）"：
	 #+BEGIN_EXAMPLE
       1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
       group default
             link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
             inet 127.0.0.1/8 scope host lo
                  valid_lft forever preferred_lft forever
             inet6 ::1/128 scope host
                   valid_lft forever preferred_lft forever
       2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast
       state UP group default qlen 1000
             link/ether ac:22:0b:52:cf:84 brd ff:ff:ff:ff:ff:ff
             inet 192.168.1.14/24 brd 192.168.1.255 scope global eth0
                  valid_lft forever preferred_lft forever
             inet6 fe80::ae22:bff:fe52:cf84/64 scope link
                   valid_lft forever preferred_lft forever
	 #+END_EXAMPLE

	 从上面的结果可看出，测试系统有2个网络接口：
	 1. lo (loopback interface)：系统用于与自己交流的虚拟接口。
	 2. eth0(Ethernet interface)：以太网接口。

	 在日常网络检测时的判断方法为：
	 1. 每个接口第一行的"UP"表示接口成功连接。
     2. “inet”项有正确的ip地址。如果使用的是DHCP(Dynamic Host
        Configuration Protocol)，有效的IP地址表示DHCP正在工作。

**** netstat
	 netstat程序可查看许多网络配置和静态数据。使用"-ie"参数可查看本地
	 网络接口（结果同"ip a"命令）。

	 使用"-r"参数可显示内核的"路由表"，即显示网络间发送数据包是怎样配
	 置的：

	 #+BEGIN_EXAMPLE
       Kernel IP routing table
       Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
       default         gateway         0.0.0.0         UG        0 0          0 wlan0
       192.168.1.0    0.0.0.0         255.255.255.0   U         0 0          0 wlan0
	 #+END_EXAMPLE

	 其他参数：
     | -a     | 显示所有正监听和没监听的线程 |
     | -l     | 仅显示正在监听的线程         |
     | -p     | 显示线程所属的程序PID        |
     | 。。。 |                              |

*** 文件传输
**** ftp
	 以在ftp.cn.debian.org服务器上下载文件为例：
	 #+BEGIN_EXAMPLE
       ftp ftp.cn.debian.org
	 #+END_EXAMPLE

	 密码为"anonymous"，密码可不填。可使用的命令有：
	 - ls：列出资源
	 - cd：文件夹跳转
	 - lcd：本地文件夹跳转
	 - get：下载指定文件
	 - bye：退出ftp程序
**** wget
	 支持http、ftp和https协议。可下载ftp文件，也可抓取网页（可递归抓取
	 整个网页，使用"-r"参数）。如抓取bing的首页：
	 #+BEGIN_EXAMPLE
       wget bing.com
	 #+END_EXAMPLE

*** 远程安全交流
	shh程序解决了rlogin和telnet两个程序的安全型问题。上2个程序同ftp程
	序一样，传输所有内容（用户名和密码）时都用纯文本。
**** ssh（Secure Shell）
	 ssh程序解决安全问题的办法是：
	 1. 远程主机需授权。
	 2. 加密传输内容。

	 SSH由两部分组成：SHH远程服务器上一直监听连接的22端口，连接远程主
	 机的SSH客户端。（登录时可使用-p参数指定端口。）

	 如需接受远程SSH连接，需安装openssh-server程序，且打开22端口接受连
	 接。

	 以远程主机remote-sys为例，ssh登录的命令为：
	 #+BEGIN_EXAMPLE
       ssh remote-sys
	 #+END_EXAMPLE

	 登录后，直到执行exit命令，才返回本地命令行。

	 登录时如果远程主机用户名与当前用户名不同，也可指定用户名，如果有
	 在remote-sys上的用户名bob，登录形式为：

	 #+BEGIN_EXAMPLE
       ssh bob@remote-sys
	 #+END_EXAMPLE

	 还可使用ssh程序在远程主机上执行单个命令：
	 #+BEGIN_EXAMPLE
       ssh remote-sys free
	 #+END_EXAMPLE

	 甚至可将在远程和本地重定向文件：
	 #+BEGIN_EXAMPLE
       ssh remote-sys 'ls *' > dirlist.txt
	 #+END_EXAMPLE

	 注意上例使用了单引号，目的是为了星号在远程主机上执行时膨胀，而不
	 是本地。
**** scp和sftp
	 OpenSSH包含2个利用SSH机密机制传输文件的程序：
	 1. scp (secure copy)。如复制remote-sys主机上home目录下的
        document.txt文件到当前目录：
		#+BEGIN_EXAMPLE
          scp remote-sys:document.txt .
		#+END_EXAMPLE

		也可指定用户名：
		#+BEGIN_EXAMPLE
          scp bob@remote-sys:document.txt .
		#+END_EXAMPLE

	 2. sftp。与ftp程序极相似，使用方法也一样。不过使用的是SSH加密通道，
        并且远程主机不需开启ftp服务。

** 文件查找
   - *locate* ：通过名称查找文件
   - *find* ：在指定文件夹下查找文件
   - *xargs* ：利用标准输入流构建命令
   - *touch* ：改变文件时间状态
   - *stat* ：显示文件或文件系统静态信息
*** locate - 简单的文件查找工具
	locate会搜索系统内包含指定字符串的文件，如已知所有程序文件都在bin
	目录下，搜索有zip关键字的程序命令为：
	#+BEGIN_EXAMPLE
      locate bin/zip
	#+END_EXAMPLE

	复杂搜着可结合其他工具使用如grep：
	#+BEGIN_EXAMPLE
      locate zip | grep bin
	#+END_EXAMPLE

	如需使用正则匹配，可使用--regexp参数：
	#+BEGIN_EXAMPLE
      locate --regexp "html$" | grep home
	#+END_EXAMPLE

	locate查找文件依赖的是系统数据库，该数据库由updatedb程序创建，默认
	每天执行一次，所有新创建的文件无法找到，可收到执行updatedb程序将新
	创建的文件写入数据库。

*** find - 复杂的文件查找工具
	与locate程序不同，find程序需指定文件夹，再更加各种属性查找，且不依
	赖数据库。比如查看home目录下有多少个文件：
	#+BEGIN_EXAMPLE
      find ~ | wc -l
	#+END_EXAMPLE

**** 过滤参数
	 - 文件类型过滤，使用-type参数。如只查找文件夹：
	   #+BEGIN_EXAMPLE
         find ~ -type -d | wc -l
	   #+END_EXAMPLE

	   只查找文件：
	   #+BEGIN_EXAMPLE
         find ~ -type f | wc -l
	   #+END_EXAMPLE

	   可过滤的文件类型选项有：
       | b | 块设备文件     |
       | c | 字符型设备文件 |
       | d | 文件夹         |
       | f | 一般文件       |
       | l | 软链接         |

	 - 文件名过滤，使用-name参数。如结果中只包含png文件：
	   #+BEGIN_EXAMPLE
         find ~ -type -f -name ".png"
	   #+END_EXAMPLE

	 - 文件大小过滤，使用-size参数。如查找大小大于1Mb的png文件：
	   #+BEGIN_EXAMPLE
         find ~ -type -f -name "*.png" -size +1M
	   #+END_EXAMPLE

	   其他表示大小的符号为：
       | b | 512byte，如过没指定符号，为默认 |
       | c | byte                            |
       | w | 2-byte                          |
       | K | kb                              |
       | M | Mb                              |
       | G | 1024Mb                          |

	   其中加号和减号表示大于和小于该值，如果省略表示为精确值。

	 - 其他常用过滤参数：
       | -cmin n        | n分钟前内容或属性修改的文件（精确值）        |
       | -cnewer file   | 内容或属性比file后修改过的文件               |
       | -ctime n       | n*24小时前修改内容或属性的文件               |
       | -empty         | 空文件                                       |
       | -group name    | group属于name（名称或ID）的文件              |
       | -iname pattern | -name参数的不区分大小写版本                  |
       | -inum n        | inode值为n的文件，对查找硬链接文件很有用     |
       | -mmin n        | 仅内容n分钟前修改的文件                      |
       | -mtime n       | 仅内容n*24小时前修改过的文件                 |
       | -newer file    | 仅内容比file后修改的文件。可用于文件backup。 |
       | -nouser        | 不属于任何用户的文件。可用于清除攻击文件。   |
       | -nogroup       | 不属于某用户组的文件                         |
       | -perm mode     | 权限为mode（可为8进制数或符号）的文件        |
       | -samefile name | 与-inum相似。与name文件有相同inode值的文件   |
       | -user name     | 属于name用户的文件                           |

**** 逻辑判断
	 以查找home目录下权限不为0600的文件，或权限不为0700的文件夹为例：
	 #+BEGIN_SRC shell-script
       find ~ \( -type f -not -perm 0600 \) -or \( -type f -not -perm -0700 \)
	 #+END_SRC

	 逻辑判断符有：
     | -or  | 或 |
     | -and | 且 |
     | -not | 非 |

	 使用括号分组，由于括号有特殊含义需转义。

**** 内置操作
	 完成搜索操作后，find程序定义了一些直接操作的参数：
     | -delete | 删除搜索结果                     |
     | -ls     | 使用相当于ls -dils的命令列出结果 |
     | -print  | 打印结果的绝对路径。（默认行为） |
     | -quit   | 一找到结果就退出                 |

**** 定制操作
	 执行定制命令的格式为：
	 #+BEGIN_EXAMPLE
       -exec 命令 {} ;
	 #+END_EXAMPLE
	 其中命令为需对搜索结果执行的命令。由于大括号和分号有特殊含义，需
	 用引号包裹，如对搜索结果执行ls命令：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.txt" -exec ls '{}' ';'
	 #+END_SRC

	 花括号实际上表示的就是搜索结果。

	 也可用-ok替代-exec，这样每次执行命令时都会询问：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.txt" -ok ls '{}' ';'
	 #+END_SRC

**** 提高操作效率
	 使用-exec执行定制命令时，实际上会对搜索结果的每条分别执行命令，如
	 需将结果作为整体执行命令，可将分号换为加号（无需引号包裹）：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.txt" -exec ls '{}' +
	 #+END_SRC

**** xargs
	 xargs程序可将标准输入流转换为多个参数（an argument list）供其它命
	 令使用。

	 如将find的结果通过管道传递给xargs，再传递给其它程序：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.html" | xargs ls -l
	 #+END_SRC

	 由于Unix系统允许文件名中含空格（甚至是换行符）。对于此情况可在
	 find程序执行时使用-print0控制输出，使用xargs时再配合--null参数使
	 用：
	 #+BEGIN_SRC shell-script
       find ~ -iname "*.png" -print0 | xargs --null ls
	 #+END_SRC

**** 其它一些常用的参数
     | -depth           | 搜索深度。如果有-delete操作会自动使用此参数                          |
     | -maxdepth levels | 最大搜索深度。传递至以后的测试和操作                                 |
     | -mindepth levels | 最小搜索深度。传递至以后的测试和操作                                 |
     | -mount           | 不搜索挂载到其它文件系统下的文件                                     |
     | -noleaf          | 让搜索过程不假设是在Unix环境而进行优化，对搜索Windos和CD-ROM文件有用 |

** 归档和备份
   - *gzip* ：压缩/解压文件。
   - *bzip2* ：“块排序（block sort）”文件压缩程序
   - *tar* ：“磁带归档（tape archiving）”应用
   - *zip* ：打包和压缩文件
   - *rsync* ：远程同步文件
*** 压缩
	压缩分有损和无损2种，有损压缩一般应用于图片和音乐文件，系统管理时
	一般使用无损压缩，所以本章介绍的压缩全是无损压缩。
**** gzip
	 gzip可压缩多个文件，压缩后的文件会替换掉原来的文件。对应的解压程
	 序为gunzip。
	 #+BEGIN_EXAMPLE
       gzip emma.txt
       gunzip emma.txt.gz
	 #+END_EXAMPLE

	 压缩后的文件名会在原文件名的基础上添加“.gz”后缀。且压缩后权限和时
	 间状态不会修改。

	 下面为gzip的一些常用参数：
     | -c    | --stdout 或 --to-stdout      | 保留原文件，将压缩结果输出到标准输出流 |
     | -d    | --decompress 或 --uncompress | 解压，相当于gunzip                     |
     | -f    | --force                      | 即使已存在文件的压缩文件，仍强制压缩   |
     | -h    | --help                       | 使用帮助                               |
     | -l    | --list                       | 显示压缩文件的压缩信息                 |
     | -r    | --recursive                  | 如果是文件夹，递归压缩                 |
     | -t    | --test                       | 测试已压缩文件的兼容性                 |
     | -v    | --verbose                    |                                        |
     | -数字 | 1到9（默认为6）              | 压缩程度                               |
	 使用“-数字”参数时，1和9分别可以--fast和--best替换。

	 gzip还可从标准输入流中获取文本压缩：
	 #+BEGIN_SRC shell-script
       ls -l /etc | gzip foo.txt.gz
	 #+END_SRC

	 如果需查看压缩文件，可将gunzip程序配合-c参数使用：
	 #+BEGIN_SRC shell-script
       gunzip -c foo.txt.gz | less
	 #+END_SRC

	 也可使用gzip对应的cat版本zcat：
	 #+BEGIN_SRC shell-script
       zcat foo.txt.gz
	 #+END_SRC

	 还可使用zless程序：
	 #+BEGIN_SRC shell-script
       zless foo.txt.gz
	 #+END_SRC
**** bzip2
	 bzip2程序的功能和使用参数基本上和gzip程序一样，使用了不同的算法，
	 压缩率更高，不过压缩速度不如gzip。

	 压缩文件添加的文件后缀名为“.bz2”。

	 对应的解压程序为bunzip2，压缩文件查看程序为bzcat。

	 还附带了bzip2recover程序，可尝试恢复损坏的.bz2文件。

*** 归档
	通常与文件压缩结合使用的时文件归档操作。归档可将多个文件绑定到一个
	大文件中，一般用于系统备份，或者将旧数据打包后转移到长期存储设备上。
**** tar
	 tar为“tap archive”的缩写，可见是Unix系统中历史悠久且经典的文件打
	 包命令。

	 压缩后的文件后缀为.tar，如果是.tgz则表示经过gzip程序压缩。

	 tar命令的参数成为mode（模式），参数前不带"-"符号。常用的一些模式
	 如下：
     | f | 指定生成文件/目标提取文件 |
     | c | 创建文件包                |
     | x | 提取文件包                |
     | r | 向文件包追加文件          |
     | t | 列出文件包中的文件        |

	 与gzip和bzip2结合使用的模式：
     | z | --gzip 或--gunzip或ungzip | 归档后使用gzip压缩文件包，或提取前使用gzip/gunzip解压 |
     | j | --bzip2                   | 归档后使用bzip2压缩文件包，或提取前使用bzip2/bunzip2解压 |

	 由于历史原因，tar命令使用与一般命令有不同之处，下面举例展示其使用
	 方法。首先创建一个测试文件夹：
	 #+BEGIN_SRC shell-script
       mkdir -p playground/dir-{001..100}
       touch playgrpund/dir-{001..100}/file-{A..Z}
	 #+END_SRC

	 mkdir的-p参数为如果父文件夹不存在，先创建父文件夹。

	 将整个playground文件夹打包：
	 #+BEGIN_SRC shell-script
       tar cf playground.tar playground
	 #+END_SRC

	 tar命令除参数无需-符号外，参数还必须放在最前。

	 列出文件夹使用tf模式，如需详细信息可添加v模式：
	 #+BEGIN_SRC shell-script
       tar tvf playground.tar
	 #+END_SRC

***** 路径问题（没怎么理解）
	  下面将归档文件在新的文件夹中提取：
	  #+BEGIN_SRC shell-script
        mkdir foo
        cd foo
        tar xf playground ../playground
	  #+END_SRC

	  查看foo文件夹可见，提取后的playground文件夹，其中的文件结构与原
	  来的文件夹完全相同。

	  除超级用户外，提取后文件的所有权为执行提取的用户。

	  tar归档文件时采用的是相对路径（即去除原文件名绝对路径前的斜杠）。
	  下面用另一种方式归档文件，再在foo文件夹中提取：
	  #+BEGIN_SRC shell-script
        tar cfv playground2.tar ~/playground
        cd foo
        tar xvf ../playground2.tar
	  #+END_SRC

	  现在在foo文件夹中就会生成home目录，提取后的playground文件夹依然
	  在里面。原有在于"~/playground"文件名会膨胀为
	  “/home/claudio/playground”。

	  #+BEGIN_QUOTE
	  此节不怎么理解。到目前为止的理解是，如果要在提取文件后文件都为绝
	  对路径，打包时就都应该使用绝对路径。
	  #+END_QUOTE

	  比如使用U盘将一台电脑上的home目录复制到另一台电脑：
	  #+BEGIN_SRC shell-script
        sudo tar cfv /media/U盘/home.tar /home
        # 另一台电脑上的操作：
        cd /
        sudo tar xfv /media/U盘/home.tar
	  #+END_SRC
	  这里假设U盘挂载到了/media文件夹中的"U盘"文件夹上。需注意的是，提
	  取前需将当前目录cd到根目录下。

***** 提取单个文件
	  在提取命令后添加文件名（路径需与打包文件中的路径完全相同），可实
	  现提取一个或多个文件。

	  如需支持wildcard还需结合--wildcards参数使用：
	  #+BEGIN_SRC shell-script
        tar xf ../playground2.tar --wildcards 'home/me/playground/dir-*/file-A'
	  #+END_SRC

***** 结合find使用
	  结合find使用可将一系列匹配的文件打包：
	  #+BEGIN_SRC shell-script
        find playground -name 'file-A' exec tar rf playground.tar '{}' '+'
        # 或者
        find playground -name 'file-A' | xargs tar rf playground.tar
	  #+END_SRC

	  使用此功能可通过timestamp文件，通过find命令的-newer参数不断备份
	  文件。

	  tar程序还可使用标准输入和输出流，如将find的结果归档后再压缩：
	  #+BEGIN_SRC shell-script
        find playground -type f -name 'file-A' | tar cf - --files-from=- | gzip > playgroundA.tgz
	  #+END_SRC

	  tar命令中的2个“-”表示标准输出/入流，会根据情况自动识别为标准输出
	  流还是标准输入流。（“-”号的此用法在其他很多和程序中还会用到）。
	  所以第一个"-"表示的是标准输出流，--files-from的值的“-”则是表示的
	  标准输入流（--from-files= - 还可用-T - 替代）。

	  经过gzip压缩后的打包文件后缀一般是.tgz，有时也用.tar.gz。

	  在tar命令中使用z或j模式，可将打包后的文件再经gzip或bzip2程序压缩：
	  #+BEGIN_SRC shell-script
        # 打包后使用gzip压缩
        find playground -type f -name 'file-A' | tar cfz playground.tgz -T -
        # 打包后使用bzip2压缩
        find playground -type f -name 'file-A' | tar cfj playground.tbz -T -
	  #+END_SRC

***** 文件远程归档
	  既然tar程序可使用管道，就可以结合ssh程序实现远程文件归档传输，如
	  将远程主机上的Document文件夹打包压缩后发送到本地：
	  #+BEGIN_SRC shell-script
        # 本地文件夹
        mkdir remote-suff
        # 远程传输
        cd remote-stuff
        ssh remote-sys 'tar cf - Documents | gzip' | tar zxf -
	  #+END_SRC
**** zip
	 zip程序是一个同时打包和压缩工具。打包压缩后的文件后缀为.zip。

	 zip的主要使用场景是兼容Windows系统。 *Unix上首选的压缩工具是gzip，
	 其次是bzip2，最后才是zip。*

	 zip程序的用法为：
	 #+BEGIN_EXAMPLE
       zip options zipfile file...
	 #+END_EXAMPLE

	 如将playground文件夹打包压缩：
	 #+BEGIN_SRC shell-script
       zip -r playground.zip playground
	 #+END_SRC
	 注意点：
	 1. 打包压缩文件夹需使用-r(recursive)参数，否则只会打包压缩空的
        playground文件夹。
	 2. 执行程序过程中，如果仅是打包会显示"stored"文件，如果有压缩会显
        示"deflat"文件，显示信息行末的百分数表示压缩量。

	 解压zip文件使用unzip程序：
	 #+BEGIN_SRC shell-script
       cd foo
       unzip ../playground.zip
	 #+END_SRC
	 注意点：
	 1. 与tar命令相反，如果文件存在，unzip解压文件时会保留原有文件而不
        是替换原有文件。
	 2. 使用-l参数可查看打包文件中的文件详情，如需更详细信息，可添加-v
        参数。不跟指定文件名（需为打包时的文名绝对路径）文件包中的所有
        文件。

	 zip程序也可使用标准输入/出流，不过不使用"-"标记，而是"-@"：
	 #+BEGIN_SRC shell-script
       find playground/ -name 'file-A' | zip -@ file-A.zip
	 #+END_SRC
	 注意：这时生成文件和原文件的顺序相反。

	 zip可使用标准输出流，可用于接受其他程序的输出结果：
	 #+BEGIN_SRC shell-script
       ls etc/ | zip ls-etc.zip -
	 #+END_SRC
	 /这里为啥又使用“-”作为标准输入流，和上一个使用find的例子不一样？？
	 ？:question:/

	 而unzip程序只能使用标准输出流，不能使用标准输入流。这样以阻止结合
	 zip和unzip通过网络复制文件。unzip使用参数-p可将结果输出到标准输出
	 流：
	 #+BEGIN_SRC shell-script
       unzip -p ls-etc.zip | less
	 #+END_SRC

*** rsyn-文件同步
	系统备份的策略之一就是将一个或多个文件夹在本地（如移动存储设备）或
	远程同步。

	比如在本地开发网站，需随时同步到远程服务器。在Unix环境中，适用于此
	情景的首选程序是rsync（remote synchronous）。其原理为快速计算2个文
	件夹的差异，复制尽量少的内容实现同步。与其他复制程序相比既高效又经
	济。

	使用方法为：
	#+BEGIN_EXAMPLE
      rsync options source destination
	#+END_EXAMPLE
	source和destination可为下面3类文件：
	1. 本地文件/文件夹。
	2. 以"[use@]host:path"形式存在的远程文件/文件夹。
	3. 以"rsync://[user@]host[:port]/path"指定的远程rsync服务器。

	注意：不支持远程对远程的文件同步。
**** 本地同步
	 下面举例展示使用rsync程序同步本地文件。首先删除foo文件夹中的内容：
	 #+BEGIN_EXAMPLE
       rm -rf foo/*
       rsync -av playground foo
       dir-100/
       dir-100/file-A

       ...

       sent 7,494 bytes  received 2,323 bytes  19,634.00 bytes/sec
       total size is 0  speedup is 0.00
	 #+END_EXAMPLE
	 - -a参数表示归档，即保证历遍文件夹中的所有文件，且保持文件属性不变。
	 - -v参数为执行过程中显示详细信息。且在执行完毕后显示复制概况。

	 再执行上一个命令：
	 #+BEGIN_EXAMPLE
       sending incremental file list

       sent 3,283 bytes  received 112 bytes  6,790.00 bytes/sec
       total size is 0  speedup is 0.00
	 #+END_EXAMPLE
	 此时不会列出任何文件，因为rsync侦测出没有文件需要复制。

	 如果修改其中一个文件再执行上个命令：
	 #+BEGIN_EXAMPLE
       touch playground/file-A
       rsync -av playground foo
       sending incremental file list
       dir-001/file-A

       sent 3,336 bytes  received 135 bytes  6,942.00 bytes/sec
       total size is 0  speedup is 0.00
	 #+END_EXAMPLE
	 这里rsync只侦测出一个文件有改动，所以只同步了它。如果改变了目标文
	 件（即foo文件夹），同步时也会侦测出来。

	 下面举一个实际点的例子。假设有一个U盘挂载到了/media/BigDisk上，将
	 重要的系统文件同步到此文件夹中：
	 #+BEGIN_SRC shell-script
       mkdir /media/BigDisk/backup
       sudo rsync -av --delete /etc /home /media/BigDisk/backup
	 #+END_SRC
	 这里首先创建了一个新文件夹，然后同步。

	 --delete参数的含义为删除backup文件夹中存在，但在系统中不存在的文
     件。首次备份可不使用，不过对以后的每次备份都很有用。

	 如需经常使用此操作，可将其作为别名添加到.bashrc文件中：
	 #+BEGIN_SRC shell-script
       alias backup='sudo mkdir -p /media/BigDisk/backup && sudo rsync -av --delete /etc /home /media/BigDisk/backup'
	 #+END_SRC

	 mkdir程序使用-p参数时，既可以在没有父文件夹时创建，也可在文件夹已
	 经存在的情况下不报错。上例就是用的第二个特性。

**** 远程同步
* Writing Shell Scripts

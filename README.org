#+TITLE: 《The Command Line Book》学习笔记
[[http://linuxcommand.org/tlcl.php/tlcl.php][书籍地址]]

* Learning The Shell
** 初试Shell
   命令行打开快捷键：<C-Alt-T>

   #+BEGIN_EXAMPLE
     me@ubuntu16.04:~$
   #+END_EXAMPLE

   以上格式含义为：用户名@电脑名:当前文件夹和$。 如果不是$，而是以
   “#”结尾表示为超级用户权限。

   导航：
   - <Up>：上一个命令
   - <Down>：下一个命令
   - <Left> <Right>：光标左右移动

   与Emacs相同的导航快捷键：
   - <C-p> ： 上一个命令
   - <C-n> ： 下一个命令
   - <C-f> 和 <C-b> ：光标左右移动

   一些简单命令：
   - *date* ：获取当前时间和日期。
   - *cal* ：显示日历。
   - *df* ：硬盘使用。
   - *free* ：内存使用情况。
   - *exit* ：退出命令行。

** 文件导航
   - *pwd* ：显示当前文件夹。
   - *ls* ：列出当前文件夹中的内容。
   - *cd* ：在文件夹中跳转。特殊用法：
     | 参数       | 效果                       |
     | cd         | 跳转到home文件夹           |
     | cd         | 跳转到上次打开的文件夹     |
     | cd ~用户名 | 跳转到"用户名"的home目录下 |
** 系统文件
*** 使用ls列出文件内容的其它用法
    *ls DIR1 FILE1* ：列出多个文件。
	参数：
    | 缩写 | 全写选项     | 作用                           |
    | a    | all          | 列出包含隐藏文件的所有文件     |
    | A    | almosall     | 同上，只是不含上级目录和根目录 |
    | d    | directory    | 单纯列出文件夹，不列出其中内容 |
    | F    | classify     | 如果为文件夹，后跟“/”          |
    | h    | humareadable | 增加文件大小可读性             |
    | l    | long         | 列出详细信息                   |
    | r    | reverse      | 逆序                           |
    | S    |              | 按文件大小排序                 |
    | t    |              | 按时间顺序                     |

	显示文件详细信息时列出的内容格式为：

	#+BEGIN_EXAMPLE
     me@ubuntu16.04:~$ ls -lh
     drwxxx  4 me me 4.0K 8月  10 19:32 dwhelper
	#+END_EXAMPLE

    drwxxx：第一个字符区分是文件还是文件夹，"d"表示文件夹，"表
    示文件；后3个字符表示所属用户读写权限；再后3个字符表示工作组成员
    读写权限？；最后3个字符表示其它用户读写权限。
	- 4：硬链接数量。
	- me：文件所属者。
	- me：文件所属组？
	- 4.0k：文件大小。
	- 8月 10 19:32：修改时间。
	- dwhelper：文件名。

*** 使用file查看文件类型
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~/Pictures$ file P6071183321.jpg
      P6071183321.jpg: JPEG image data, Exif standard: [TIFF image data, littlendian, direntries=18, GPData, model=m2]
	#+END_EXAMPLE
*** 使用less查看文件内容
	阅读快捷键与Vi相同。
*** 系统目录概览
	- /： 根目录，包含所有文件。
	- /bin：系统启动和运行时必须的文件。
	- /boot：含Linux内核、initial RAM disk image (for drivers needed
      at boot time)和启动加载器（boot loader）。 比如：
	  - /boot/grub/grub.cfg：用于配置启动加载器。
	  - /boot/vmlinuz（名称可能不一）：Linux内核
	- /dev：所有设备（device）的列表。
	- /etc：包含所有应用于整个系统的配置文件，以及系统服务启动的shell
      脚本。所有文件都为纯文本文件。 比如：
	  - /etc/fstab：储存设备及其挂载点。
	  - /etc/crontab：automated jobs何时启动。
	  - /etc/passwd：用户账号信息。
	- /home：普通用户文件操作区域。
	- /lib：包含系统核心程序公用库文件（与Window的DLL文件类似）。
	- /lost+found：系统崩溃后恢复使用。如果系统不出现严重错误，此文件夹为空。
	- /media：如USB和CROM等移动设备的挂载点文件。
	- /mnt：老旧Linux系统中，该文件夹含手动挂载的移动设备文件。
	- /opt：主要用于保存商业软件。
	- /proc：其内容并不在硬盘中，只含内核的虚拟文件。其中文件可读，说
      明内核如何读取电脑信息。
	- /root：root用户的根目录。
	- /sbin：含超级用户执行重要系统任务所需二进制文件。
	- /tmp：含不同程序执行时创建的临时文件。通过配置，可实现系统重启时，
      不含任何内容。
	- /usr：最大的文件夹。含普通用户的所有程序和支持文件。
	- /usr/bin：不同Linux分支安装的执行文件。容量很多。
	- /usr/lib：含/usr/bin文件夹中的共享库文件。
	- /usr/local：不含Linux分支程序，而含整个系统使用程序？。通过源码
      编译安装的程序在/usr/local/bin文件夹中。系统安装后就有此文件夹，
      但当管理员安装某些程序后，此文件夹才有内容。
	- /usr/sbin：含其它管理员安装程序。
	- /usr/share：含与/usr/bin文件夹下的程序共享的所有数据，比如配置文
      件、图标、屏幕背景和声音文件等。
	- /usr/share/docs：绝大多数安装软件都有文档，就放置在其中。
	- /var：除/tmp和/home外，其它文件夹相对静态，改变不大。此文件夹主
      要存储更新频繁的数据，如数据库和用户邮件等。
	- /var/log：含日志文件，记录系统活动情况。其中最有用的是
      /var/log/message和（或）/var/log/syslog文件。出于安全考虑，需将
      其权限设置为超级用户。

*** 软链接（Symbolic Links或Soft Links）
	使用"ls"命令时，有时会出现类似如下的结果，其中>"表示该文件有软链接：

	#+BEGIN_EXAMPLE
	lrwxrwxrwx 1 me me 11 200011 07:34 libc.so.6> lib2.6.so
	#+END_EXAMPLE

	比如某个程序需共享"foo"文件，而此文件版本更新频繁，可在文件名后增
	添版本号。不过，如果此文件每次更新后，需更改共享此文件程序的软件配
	置。

	软链接的作用就在于，比如现在安装了2.6版本的"foo"，文件名为
	"fo2.6"。此时就可创建一个软链接"foo"指向"fo2.6"，读取"foo"文件
	时实质上是读取的"fo2.6"文件。当更新至2.7版本时，重置此软链接即可。

*** 硬链接
	既然有软链接，也有硬链接，也可使文件有多个名字，不过机制不同，下章介绍。

** 文件操作
   - *cp* ：复制文件
   - *mv* ：移动/重命名文件
   - *mkdir* ：创建文件夹
   - *rm* ：删除文件
   - *ln* ：创建软链接和硬链接

*** 通配符（Wildcard/Globbing）
	使用通配符可快速选择和过滤文件,通配符有：

    | \*            | 匹配任意长度的任意字符             |
    | ?             | 匹配一个字符                       |
    | [characters]  | 匹配任意一个characters中的字符     |
    | [!characters] | 匹配任意一个不是characters中的字符 |
    | [ [:class:] ] | 匹配满足class的一个字符            |

	其中class可为:

    | [:alnum:] | 字母或数字 |
    | [:alpha:] | 字母       |
    | [:digit:] | 数字       |
    | [:lower:] | 小写字母   |
    | [:upper:] | 大写字母   |

	举例:

    | \*                | 所有文件                                      |
    | g*                | 所有以g开头的文件                             |
    | b*.txt            | 所有以b开头,中间为任意字符,再以.txt结尾的文件 |
    | Data???           | 以Data开头的,后跟3个字符的文件                |
    | [abc]*            | 以a,b或c开头的文件                            |
    | [ [:upper:] ]*    | 以大写字母开头的文件                          |
    | [ ![:digit] ]*    | 以非数字开头的文件                            |
    | *[ [:lower:]123]  | 以一个小写字母或1,2,3j结尾的文件              |
*** mkdir ...
	可同时创建多个文件夹
*** cp 复制文件
	参数：

    |archive             | 同时复制所有权和权限           |
    |interactive         | 如需覆盖已有文件，询问         |
    |recursive           | 同时复制子文件夹               |
    |update              | 只复制目标文件夹中不存在的文件 |
    |verbose             | 显示详细信息                   |

	例子：

    | cp file1 file2      | 复制file1到file2。如果file2已存在，覆盖；不存在，创建              |
    | cpi file2 file2     | 如果file2已存在，提示是否覆盖                                      |
    | cp file1 file2 dir1 | 将file1和file2复制到dir1文件夹。dir1需已存在                       |
    | cp dir1/* dir2      | 将dir1中的所有文件复制到dir2。dir2需已存在}                        |
    | cpr dir1 dir2       | 将dir1中的所有内容复制到dir2。如果dir2不存在，创建；已存在，仅复制 |
*** mv 移动或重命名文件
	参数和用法与cp相似，只是操作完成后原文件会被删除。
*** rm 删除文件
	参数：
    |interactive       | 删除前提醒                                          |
    |recursive         | 如果是文件夹，且删除其中的子文件夹，需添加此选项    |
    |force             | 不管文件是否存在，都删除。可interactive选项       |
    |verbose           | 显示操作信息                                        |

	例子：
    | rm file1          | 删除file1                                               |
    | rmi file1         | 同上例唯一不同在于，删除前提醒                          |
    | rmr file1 dir1    | 删除file1，删除dir1及其中内容                           |
    | rmrf file1 dir1   | 与上例唯一不同在于，不管file1和dir1是否存在，都执行命令 |
*** ln 创建链接

	创建连接：
	#+BEGIN_EXAMPLE
	me@ubuntu16.04:~$ ln file link
	#+END_EXAMPLE

	创建软链接：
	#+BEGIN_EXAMPLE
	me@ubuntu16.04:~$ lns item link
	#+END_EXAMPLE

**** 硬链接
	 硬链接是Unix创建链接的传统方式，不如软链接先进。每个文件默认有一
	 个为其名字创建的硬链接。自行创建硬链接时，实质上是为文件创建了额
	 外文件夹入口？。硬链接有两大不足：

	 不能在不同分区间创建硬链接。
	 只能为文件，不能为文件夹创建硬链接。

	 与软链接不同，当使用"lsl"命令查看时，硬链接文件的显示方式与普通
	 文件无区别。当硬链接被删除时，只是链接被删除，但所占内存依然存在，
	 当指向该文件的所有链接都被删除后才释放。 _尽量避免使用硬链接。_
**** 软连接
	 软链接的目的就是弥补硬链接的短处。如果为文件或文件夹创建软链接，
	 则生成一个特殊文件，含一个指向引用文件或文件夹的文本指针。

	 如果修改软链接中的内容，引用文件中的内容也会随之改变。删除软链接
	 后，引用文件并不被删除；如果文件先被删除，软链接依然存在，只是不
	 指向任何文件，此状态为软链接被损坏，当使用"ls"命令时，会使用不同
	 的颜色显示。
*** 实践
** 充分利用命令行
   - *type* ：命令来源
   - *which* ：命令对应的执行程序位置
   - *help* ：内置shell命令帮助文档
   - *man* ：显示命令的手册页
   - *apropos* ：通过手册文件查找命令
   - *info* ：显示命令的info文件
   - *whatis* ：显示命令的精简描述
   - *alias* ：为命令取一个别名（alias）
	 创建前先通过 *type* 命令查看是否存在，避免冲突。

	 不带任何参数可查看所有已创建的别名。
   - *unalias* ：删除别名。

   命令可分4大类：
   1. *可执行程序* 比如/usr/bin内的文件。此类程序也可为编程语言（如
      C等）编译成的二进制文件。
   2. *shell内置命令（shell buitins）* 如"cd"命令。
   3. *shell脚本*
   4. *别名（alias）* 使用其它命令创建的命令。

** 重定向
   - *cat* ：合并文件
   - *sort* ：排序文本
   - *uniq* ：显示/排除重复行
   - *grep* ：使用正则匹配行
   - *wc* ：统计行数、单词数和字节数（byte）
   - *head* ：显示文件前面部分
   - *tail* ：显示文件后面部分
   - *tee* ：从标准输入流读入，写入文件同时还可在管道中传递

*** 标准输入流、输出流和错误流

	目前为止学习到的命令都会有输出内容，其主要有两类：程序执行结果，状态和
	错误信息。

	按Unix"一切皆文件"的说法，以"ls"命令为例，其结果输入到标准输出流
	（stdout）这一特殊文件，状态和错误信息输入到标准错误流（stderr）另外一
	个特殊文件。默认情况下，者两个文件只是关联到显示屏，不对向硬盘写入任何
	数据。

	此外，标准输入流（stdin）则默认关联到键盘。

	重定向标准流后，可使输出不止在显示屏上，输入不止来自键盘。
*** 重定向标准输出流
	使用重定向操作符">"可将标准输出流从显示屏重定向到文件。如果对文件
	操作，会先清空文件内容。

	使用重定向操作符">>"可向文件末尾追加内容，不用完全改写。
*** 重定向标准错误流
	重定向错误流没有专门的操作符，需使用类型编号。0,1和2分别代表标准输入流输出流和错误流。

	#+BEGIN_EXAMPLE
	me@ubuntu16.04:~$ lsl /bin/usr 2> lerror.txt
	#+END_EXAMPLE
*** cat命令参数
	|shoall                 | 等价vET                                    |
	|numbenonblank          | 只为非空行显示行数，可重n选项              |
	|e                      | 等价vE                                     |
	|shoends                | 每行末尾显示"$"                             |
	|n                      | 为每行显示行数                              |
	|squeezblank            | 将重复空行合并为一行                        |
	|t                      | 等价vT                                     |
	|shotabs                | 将TAB字符显示为^I                           |
	|shononprinting         | 使用^和形式显示不可打印字符，LFD和TAB除外   |

** 命令处理
   *echo* ：输出。
   #+BEGIN_EXAMPLE
	 me@ubuntu16.04:~$ echo this is a test
	 this is a test
   #+END_EXAMPLE

   输入命令，按下Enter后，如”\*“，bash将命令处理后，shell才执
   行。bash处理的过程称为膨胀（expansion)。

*** 命令膨胀
**** 路径膨胀 *
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo D*
       Desktop Documents Downloads
       me@ubuntu16.04:~$ echo *s
       Documents Downloads Pictures Templates Videos
       me@ubuntu16.04:~$ echo [[:upper:]]*
       Desktop Documents Downloads Music Pictures Public Templates Videos
	 #+END_EXAMPLE
**** 波浪字符膨胀 ~
	 与cd命令相同，“~”表示用户的home文件夹路径。

	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo ~
	 #+END_EXAMPLE
**** 数学运算膨胀 $(())
	 基本形式：
	 #+BEGIN_EXAMPLE
	 echo $((2 + 2))
	 #+END_EXAMPLE

	 嵌套形式：
	 #+BEGIN_EXAMPLE
	 me@ubuntu16.04:~$ echo $(( (5**2) * 3 ))
	 #+END_EXAMPLE

	 *不支持浮点数，如5/2的结果为2 。*

	 支持的运算有：
     | +  | 加   |
     | -  | 减   |
     | *  | 乘   |
     | /  | 除   |
     | %  | 求模 |
     | ** | 次方 |

**** 花括号膨胀 ${}
	 可使用以逗号隔开的列表形式：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo Front{A,B,C}Back
       FrontBack FrontBack FrontBack
	 #+END_EXAMPLE

	 也可使用范围形式：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo Number_{1..5} #数字范围
       Number_1 Number_2 Number_3 Number_4 Number_5
       me@ubuntu16.04:~$ echo Number_{01..5} #长度补齐
       Number_01 Number_02 Number_03 Number_04 Number_05
       me@ubuntu16.04:~$ echo Number_{001..5}
       Number_001 Number_002 Number_003 Number_004 Number_005
       me@ubuntu16.04:~$ echo {Z..A} #字母范围
       Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
	 #+END_EXAMPLE

	 利用此功能同时生成多个文件夹：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mkdir Log
       me@ubuntu16.04:~$ cd Log/
       me@ubuntu16.04:~/Log$ mkdir {2016..2017{01..12}
       me@ubuntu16.04:~/Log$ lsp
	 #+END_EXAMPLE

**** 命令替换 ${命令}
	 将执行结果作为表达式输出：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$
       me@ubuntu16.04:~$ echo $(ls)
       Desktop Documents Downloads ...
	 #+END_EXAMPLE

	 列出cp对应程序的详细信息：
	 #+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ lsl $(which cp)
     rwxxx 1 root root 151024 2月  18 21:37 /bin/cp
	 #+END_EXAMPLE

	 结合管道使用：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ file $(lsd /usr/bin/* | grep zip)
	 #+END_EXAMPLE

*** 命令中的引号
	- echo命令的参数间，多余的空格被移除:
	  #+BEGIN_EXAMPLE
        me@ubuntu16.04:~$ echo this is a       test
        this is a test
	  #+END_EXAMPLE
	- $1变量未定义：
	  #+BEGIN_EXAMPLE
        me@ubuntu16.04:~$ echo The total is $100.00
        The total is 00.00
	  #+END_EXAMPLE

**** 双引号
	 将命令参数放入双引号中后，除参数膨胀、数学运算膨胀和命令替换膨胀
	 外的膨胀都失去意义；还有就是反引号和斜杠外的特殊字符外都失去意义。

	 可使用双引号操作有多余空格的文件名，如：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ lsl "two words.txt"
	 #+END_EXAMPLE
**** 单引号
	 去除所有特殊字符的意义。
**** 转义字符
	 转义字符需使用斜杠修饰。如：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo "The balance for user $USER is: \$5.00"
       The balance for user claudio is: $5.00
	 #+END_EXAMPLE

	 可用于操作特殊文件名：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mv bad\&filename good_filename
	 #+END_EXAMPLE

	 使用echo命令打印特殊字符时，需使用双引号（单引号中无特殊字符含义），
	 且配e参数使用：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ echo "hello\nword"
       hello\nword
       me@ubuntu16.04:~$ echoe "hello\nword"
       hello
       word
	 #+END_EXAMPLE

	 常用的转义字符有：
     | \a | beep            |
     | \b | Backspace       |
     | \n | Newline         |
     | \r | Carriage Return |
     | \t | Tab             |

** 快捷键
   快捷键基本上都与Emacs的快捷键相同。

*** 历史命令
	使用 *history* 命令可查看历史命令：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ history | grep /usr/bin
      ...
      88 lsl /usr/bin > loutput.txt
      ...
	#+END_EXAMPLE

	上例中的88为该命令在历史命令中的排序。可使用此序号重新执行：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ !88
      ...
	#+END_EXAMPLE

**** 搜索历史命令
	 - r：交互式搜索历史命令。
	 - j：粘贴搜索到的历史命令。
	 - g 或 c：退出交互式搜索历史命令。

**** 历史命令膨胀
     | !!       | 重复上一条命令                 |
     | !N       | 重复第N条历史命令              |
     | !String  | 重复上一条以String开头的命令   |
     | !?String | 重复上一条包含String的历史命令 |

** 权限

   - *id* ：显示用户身份信息
   - *chmod* ：更改文件模式（权限）
   - *unmask* ：设置文件默认权限
   - *su* ：更换用户运行shell
   - *sudo* ：更换用户执行命令
   - *chown* ：更改文件所有权
   - *chgrp* ：更改文件用户组所有权
   - *passwd* ：更改用户密码

*** 用户、用户组和全局权限
	尝试读取/etc/shadow文件。读取失败。原因为普通用户没有权限读取此文
	件：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ file /etc/shadow
      /etc/shadow: regular file, no read permission
      me@ubuntu16.04:~$ less /etc/shadow
      /etc/shadow: Permission denied
	#+END_EXAMPLE

	文件所有权限有3种形式：
	1. _用户_：如果文件/文件夹权限属于某用户，该用户可控制其访问权限。
	2. _用户组_：如果文件/文件夹属于用户组，用户组成员可访问。
	3. _全局_：如果文件/文件夹权限属于全局，所有用户可访问。

	当用户账号创建后，被赋予一个ID/uid，和一个主要用户组ID/gid，并可能
	属于某个用户组。 使用 *id* 命令可显示当前用户身份信息：

	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ id
      uid=1000(me) gid=1000(me)
      groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
      ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
	#+END_EXAMPLE

	以上信息中，用户账号存储在/etc/passwd文件中，用户组信息存储在
	/etc/group文件中。当用户账号创建后，以上2个文件随/etc/shadow文件
	（存储用户密码）更改。对各用户账号而言，/etc/passwd文件定义了该用
	户的登录名、uid、gid、账号真实名、home文件夹以及登陆shell。在
	/etc/passwd和/etc/group文件中，都定义了一个uid为0的的用户，便是超
	级用户。

*** 读、写和执行权限
	文件权限有3种：读、写和执行。使用 *lsl* 命令可查看：

	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ > foo.txt
      me@ubuntu16.04:~$ lsl foo.txt
     r 1 me me 0 8月  18 15:03 foo.txt
	#+END_EXAMPLE

	返回结果中，第一区域中的10个字符表示_文件属性_。其中第一个字母表示_文
	件类型_，以下为常见的文件类型：

    | - | 普通文件                                                           |
    | d | 文件夹                                                          |
    | l | 软链接，剩余的9个属性字符都为“rwxrwxrwx”，真实文件属性同其指向文件 |
    | c | 字符型文件                                                    |
    | b | 设备型文件                                                         |

	剩余的9个字符3个一组，分别代表用户权限、用户组权限和全局权限。
	“rwx”3个字符分别代表的含义：

	- r（只读）对文件而言，允许打开和读取；对文件夹而言，如果有执行属
      性，允许列出文件夹中的内容。

	- w（写入）允许文件被写入和清空，但不允许被重命名和删除，重命名和
      删除权限取决于所在文件夹的权限；对文件夹而言，允许在文件夹中创建
      和 删除文件，如果有执行属性，允许重命名其中的文件。

	- x（执行）允许文件被视作程序，并被执行。使用脚本语言编写的文件需
      设 置只读和执行权限；对文件夹而言，允许进入文件夹，如执行“cd
      directory”命令。

**** 使用chmod命令更改文件权限
	 只有拥有用户和超级用户才有权限使用chmod命令修改文件模式。有使用八
	 进制数和字符2中方式改变文件模式。

	 八进制数、二进制数和文件模式对比表：

     | 0 | 000 |     |
     | 1 | 001 |     |
     | 2 | 010 | x   |
     | 3 | 011 | wx  |
     | 4 | 100 | r   |
     | 5 | 101 | rx  |
     | 6 | 110 | rw  |
     | 7 | 111 | rwx |

	 使用符号修改文件模式时，其中的符号由3部分组成：目标用户、操作（添
	 加/删除）和权限。

     | u | “user”的缩写，表示文件拥有用户             |
     | g | 拥有用户组                                 |
     | o | “others”的缩写，除拥有用户和用户组的用户？ |
     | a | “all”的缩写，即“u”、“g”和“o”的结合         |

	 表示操作的符号有：
     | + | 添加权限                               |
     | - | 删除权限                               |
     | = | 删除所有已有权限，仅使用此处设置的权限 |

	 例：
	 - u+x_：为拥有用户添加执行权限。
	 - -x：删除拥有用户的执行权限。
	 - +x：为拥有用户、用户组和全局用户添加执行权限，等价于“a+x”。
	 - rw：删除除拥有用户和用户组外，用户的读和写权限。
	 - go=rw：将拥有用户组和全局用户的权限设置为读和写。如果拥有用户和
       其它用户有执行权限，删除。

**** 使用unmask命令设置文件默认权限
	 不跟任何参数，查看mask值：

	 例子：
	 #+BEGIN_EXAMPLE
       claudio@claudio:~$ umask #查看umask值
       0002
       claudio@claudio:~$ > foo.txt #新建文件
       claudio@claudio:~$ lsl foo.txt #查看其mask值
      r 1 claudio claudio 0 8月  20 13:33 foo.txt
       claudio@claudio:~$ umask 000 #重置mask值
       claudio@claudio:~$ rm foo.txt #删除该文件并新建
       claudio@claudio:~$ > foo.txt
       claudio@claudio:~$ lsl foo.txt #查看新建文件权限
      rrr 1 claudio claudio 0 8月  20 13:34 foo.txt
	 #+END_EXAMPLE

*** 添加用户和用户组
	http://blog.csdn.net/lele52141/article/details/6593840

	执行命令“adduser”根据提示设置密码和其它选项即可。

	"useradd"和“adduser”命令的区别在于，后者是前者的简单化版本，通过提
	示完成操作；前者每个参数需手动配置。

	“userdel”命令可删除用户。下面为其选项：
	- fforce：强制删除用户账号，即使是当前登陆账号也可。同时强制删除该
      用户的的home文件夹和mail spool，即使另一个用户也使用该home文 件
      夹，或者该mail spool不属于特定用户。

	- remove：删除该用户的home文件夹和mail spool，但文件系统中的相关文
      件需手动删除。

*** 更换用户
	更换用户有3种方法：
	1. 在图形界面更换用户
	2. 使用su命令
	3. 使用sudo命令

	其中后面两种可在当前shell实例（shell session，即打开的shell窗口）
	中操作，更方便。su命令更改当前用户，进入新的shell实例，或者使用新
	用户账号执行单个命令。

	使用sudo命令，可使管理员配置/etc/sudoers文件，指定某用户可执行的命
	令。

	sudo还是su命令的用法在不同版本（如ubuntu）中用法差异较大，有的版本两个
	命令都有。

	#+BEGIN_QUOTE
	进入新用户shell实例后，使用命令sudo时，会报错"\[用户名] is not in
	the sudoers file"。解决办法参考：
	<http://askubuntu.com/questions/151200/mmaiusernaminoithsudoerfile>

	即修改/etc/sudoers文件。编辑此文件后，如果写入内容有语法错误，会导致
	sudo命令不能正常运行，解决方法为 [执行pkexec visudo命令。参考：
	http://askubuntu.com/questions/73864/hotmodifinvalietsudoerfilithrowouaerroannoallowi
	#+END_QUOTE

	使用命令 *sudo -l* 可查看sudo可执行的命令。
**** chown改变文件所有权
	 - chown bob file：将文件所有权从当前用户转交到bob。
	 - chown bob:users file：将文件所有权从当前用户转交到bob，并将文件
       所有权用户组改为users
	 - chown :admins fils： 将文件所有权用户组改为admins，用户所有权不
       变
	 - chown bob:：将文件所有权从当前用户转交到bob，并将所有权用户组更
       改为用户bob的登陆用户组

*** 修改密码
	使用命令passwd修改密码。用法passwd [user]，如果不指定user，则修
	改当前用户密码。

*** 实践
** 进程
   - *ps* ：报告当前所有进程概况
   - *top* ：显示所有任务
   - *jobs* ：列出活动jobs
   - *bg* ：将一个job置于后台
   - *fg* ：将一个job置于前台
   - *kill* ：向单个进程发送信号（signal）
   - *killall* ：通过名字杀死进程
   - *shutdown* ：关闭或重启系统

*** 进程如何工作
	系统启动时，内核将多个自身活动作为进程初始化，并启动名为init.init
	的程序。init.init程序反过来运行一系列位于/etc目录下的shell脚本，利
	用这些脚本启动所有系统服务。这些服务中许多为后台程序（daemon
	programs），不提供用户界面。所以，即使系统启动后，没有登陆前，系统
	也在运行许多日常服务。

	利用父进程（parent process）和子进程（child process）的机制，一个
	程序可启动其它多个程序。

	为使整个系统更有条理，内核负责维护每个进程的信息。比如，每个进程都
	被赋值一个进程ID（process ID，PID）。赋值PID采用递增模式，其中init
	进程的PID始终为1。内核同时还跟踪分配给每个进程的内存，以及进程执行
	状态？。同文件一样，进程也有所有者和用户ID、有效用户ID等。

*** 查看进程
	查看进程最常用的命令为ps，其选项较多，下面介绍几种常用选项。

	不带任何参数，显示当前shell实例中打开的进程：
	#+BEGIN_EXAMPLE
      # 只用当前shell实例运行了ps一个进程
      me@ubuntu16.04:~$ ps
        PID TTY          TIME CMD
       5801 pts/20   00:00:00 bash
       6033 pts/20   00:00:00 ps
	#+END_EXAMPLE

	使用x选项查看当前用户所有的所有进程：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ ps x
        PID TTY      STAT   TIME COMMAND
       3021 ?        Ss     0:00 /lib/systemd/systemuser
       3022 ?        S      0:00 (spam)
       3028 ?        SLl    0:00 /usr/bin/gnomkeyrindaemodaemonizlogin
       3030 ?        Ss     0:00 /sbin/upstaruser
      ...
	#+END_EXAMPLE

	每列字符的含义为：
	- TTY：teletype，控制此进程的shell实例。“?”表示此进程不属于任何   |
      shell实例。

	- TIME：CPU处理此进程所耗时间。

	- STAT：“state”的缩写，表示该进程的状态。STAT中各字符含义：
	  - R：Running。表示此进程正在/准备运行。
	  - S：Sleeping。此进程暂时没有运行，在等待触发事件，如键盘输入等。
	  - D：Uninterruptible Sleep。正在等待I/O，如硬盘驱动。
	  - T：Stopped。已被发送指令停止。
	  - Z：死掉/“僵尸”（zombie）程序。此进程为已停止运行的子进程，但并
        没有被其父进程清除。
	  - <：高优先权进程。可为进程授权更高的权重，提供更多的CPU计算时间。
        此属性称为“谦让性（niceness）”。如果进程优先权越高，其“谦让性”
        就越低。因为其占用的更多的CPU计算时间，留给其它进程的时间就更
        少。
	  - N：低优先权进程。其它进程服务启动后，才开始占用CPU计算。

	使用aux选项查看更详细的进程信息：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ ps aux
      USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
      root         1  0.0  0.1 119936  6148 ?        Ss   05:56   0:01 /sbin/init spla
      root         2  0.0  0.0      0     0 ?        S    05:56   0:00 [kthreadd]
      root         3  0.0  0.0
      ...
	#+END_EXAMPLE

	其中各行的含义为：
    | USER  | 用户ID。该进程的拥有者                     |
    | %CPU  | CPU使用百分比                              |
    | %MEN  | 内存使用百分比                             |
    | VSZ   | 所占虚拟内存大小                           |
    | RSS   | 物理内存（RAM）使用量（单位kb）            |
    | START | 进程开启时间。如果超出24小时，以"天"为单位 |

*** 控制进程
**** 取消进程
	 使用<C-c>快捷键可取消进程。
**** 将进程放到后台
	 如需运行一个程序，但又希望继续使用当前shell实例，可将此程序置于后
	 台。

	 执行程序，并立即将其置于后台，在后添加“&”符号：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ xlogo &
       [1] 4980
       me@ubuntu16.04:~$
	 #+END_EXAMPLE

	 返回值[1] 4980为job控制信息，其中数字1（“[1]”）表示job数字，
	 “4980”表示PID。

	 执行ps命令，可看到置于后台的进程：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ ps
       PID TTY          TIME CMD
       4979 pts/12   00:00:00 bash
       4980 pts/12   00:00:00 xlogo
       4981 pts/12   00:00:00 psw
	 #+END_EXAMPLE

	 可使用job命令列出当前shell实例打开的jobs：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ jobs
       [1]+ Running      xlogo &
	 #+END_EXAMPLE

	 上面返回的含义为，只有一个job，编号为“1”，正在运行，且启动命令为
	 xlogo &。

**** 将进程从后台来回前台
	 命令行无法直接控制后台运行的程序，需使用fg命令将其拉回前台：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ jobs
       [1]+ Running      xlogo &
       me@ubuntu16.04:~$ fg %1w
	 #+END_EXAMPLE

	 其中“%1”为job膨胀，“1”为需要置于前台的job编号（jobspec）。

	 使用fg和bg命令时，如果jobs只有1个，可省略job编号膨胀（%1）。

**** 暂停进程
	 后台运行程序与暂停程序的区别在于，前者正常运行，后者不运行，但没
	 有关闭。命令为z。
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ xlogo
       # Ctrz
       [1]+ Stopped      xlogo
       me@ubuntu16.04:~$
	 #+END_EXAMPLE

	 此时如果缩放xlogo程序图形界面，“X”图标不会跟随缩放，证明此程序已
	 被暂停。

*** 信号
	使用kill命令可“杀死”进程：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ xlogo & # 启动xlogo程序，并置于后台
      [1] 6274 # 输出job编号和PID
      me@ubuntu16.04:~$ kill 6274 # 利用PID终止进程（也可使用job编号膨胀）
	#+END_EXAMPLE

	kill命令并不是真正“杀死”进程，而是向进程发送了信号（signal）。信号
	是操作系统与程序交流的方式之一。比如上面使用的快捷键Ctrc和Ctrz，
	当命令行接受这两个快捷键是，实际上是分别向前台程序发送了
	INT（Interrupt）和TSTP（Terminal Stop）信号。程序方面，一直都在“监
	听”信号，并对应用在自身的信号做出反应。

	基本用法：kill signal] PID...。如果不提供选项，默认发送
	TERM（Terminate）信号。常用信号有（括号内为等价数字代码）：

	- HUP（1）。Hangup，向程序支出控制命令行已经“挂起”。与关闭控制该程
      序的命令行效果一样？。该命令行内的前台程序接受此信号后，停止运行；
      对后台程序而言，实现重新初始化的效果。即，当后台程序接受此信号后，
      重启并重新读取其配置文件，Apache服务器就是使用如此使用HUP信号？。

	- INIT（2）。Interrupt，与使用<C-c>效果相同，通常会通知程序。

	- KILL（9）。,Kill，是个特殊信号。由于不同程序处理信号的方式不同，
      如完全忽视，此信号实际上并不直接发送给目标程序，而是通过内核立即
      终止进程。用此方式终止的进程，无法“clean up”和保存内容？。因此
      KILL信号应当在所有终止信号尝试失败时才使用。

	- TERM（15）。Terminate，**kill命令使用的默认信号**。如果某个程序
      依然“活跃（alive）”，将被终止。

	- CONT（18）。Continue，恢复接收STOP信号后的进程。与使用
      <C-z>快捷键，在将其置于后台效果相同。

	- STOP（19）。Stop，使进程暂停，效果如<C-z>快捷键。同KILL信号一样，
      并不直接发送给目标进程，所以无法忽略。

	例：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ xlogo & # 将程序置于后台
      [1] 123456
      me@ubuntu16.04:~$ kill1 123456 # 发送HUP信号
      claudio@claudio:~$ # 按回车
      [1]+  Hangup                  xlogo # 显示接收信号后的信息
	#+END_EXAMPLE

	可使用数字、名称和带“SIG”前缀的名称发送信号。下面3种方式等价：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ xlogo &
      [1] 123456
      me@ubuntu16.04:~$ kill1 123456 # 使用数字
      me@ubuntu16.04:~$ xlogo &
      [1] 123456
      me@ubuntu16.04:~$ killHUP 123456 # 使用名称
      me@ubuntu16.04:~$ xlogo &
      [1] 123456
      me@ubuntu16.04:~$ killSIGHUP 123456 # 使用带前缀的名称
	#+END_EXAMPLE

	下面列出一些系统常用的信号及其含义：
	- QUIT（3）。Quit，放弃。

	- SEGV（11）。Segmentation Voilation，如果某程序非法使用内存，即尝
      试在不允许的文件写入数据时发送此信号。

	- TSTP（20）。Terminal Stop。当<C-z>按下时命令行发出的信号。不想
      STOP信号，程序接收到TSTP信号后，可选择忽略。

	- WINCH（28）。Window Change，当程序所在窗口缩放时，系统发出的信号。
      如top和less程序，接受到此信号后更改行为，以使用当前窗口大小。

	查看所有kill可接受的选项使用l”选项：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ kill -l
	#+END_EXAMPLE

**** killall 向多个进程同时发送信号
	 使用killall命令可以同时向多个进程（可指定所属用户或某类），基本用
	 法为killall u user] signal] name...。

	 运行多个xlogo实例后，使用killall命令通知发送终止信号：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ xlogo &
       [1] 7788
       me@ubuntu16.04:~$ xlogo &
       [2] 7789
       me@ubuntu16.04:~$ killall xlogo
       me@ubuntu16.04:~$ # 再次按下回车键才能显示结果
       [1  Terminated              xlogo
       [2]+  Terminated              xlogo
	 #+END_EXAMPLE

	 与kill命令相同，向所有权不为当前用户的进程发送信号，需要超级权限。

*** 关闭系统
	有4个命令可关闭系统：halt、poweroff、reboot和shutdown，其
	中前3个为按其名称就可知道其功能，且安装它们的手册描述，都仅为向后
	兼容保留的命令，不如shutdown应用灵活（可实现halt、poweroff、
	reboot和shutdown功能，还可指定时间）。

*** 其它常用进程命令
	检测进程是系统管理的重要任务，有许多相关命令，下面介绍4个：
	- pstree：以树状形式列出进程，突出父进程和子进程关系。
	- vmstat：显示系统资源使用概况，包括内存、交换分区和硬盘I/O（disk
      I/O）。如需实时更新，可在后面跟上间隔描述，如vmstat 5，结束使
      用<C-c>命令。
	- xload：使用图像界面实时绘制系统负载。
	- tload：与xload功能相同，不过是在命令行绘制。

* Configuration And The Environment
** 环境
   每一个shell实例都有一个对应环境（enviroment）。各程序使用此环境中的
   数据侦测系统配置。尽管绝大多数程序使用配置文件储存自身设置，但还是
   有一些依赖环境。

   - *printenv* ：打印部分或全部环境数据
   - *set* ：显示shell选项
   - *export* ：向执行程序导入环境数据？
   - *alias* ：使用命令创建别名
*** 何为环境
	环境中，shell存储2类数据：环境变量和shell变量。bash负责存储shell变
	量，除此之外的为环境变量。除变量外，shell还存储别名和shell函数。
**** 检测环境
	 使用shell内置函数set和printenv程序可查看环境中存储的数据，前者显
	 示shell和环境变量，后者只显示环境变量。

	 查看环境变量，结合less命令：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ printenv | less
	 #+END_EXAMPLE

	 使用printenv查看单个变量值：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ printenv USER
	 #+END_EXAMPLE

	 使用set函数查看shell变量、环境变量和shell函数，结果通常按字母排序：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ set | less
	 #+END_EXAMPLE

	 set和printenv都不显示别名，需使用alias命令：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ alias
	 #+END_EXAMPLE

**** 变量举例
	 下列变量因系统差别较大，仅以本机为例：

	 - DISPLAY：如果为图像环境，返回值为显示实例名称，通常为":0"，即X
       server生成的第一个显示实例。
	 - SHELL：shell程序名称。
	 - HOME：home文件路径。
	 - LANG：本机语言设置。
	 - PATH：执行程序时，对应搜索路径，用冒号隔开。
	 - PS1：Prompt String 1。shell对话字符串。
	 - PWD：当前目录。
	 - TERM：命令行类型。类Unix系统支持多种命令行协议；此变量用于设置
       本机命令行模拟器。
	 - USER：用户名。

*** 环境如何建立

	当登陆系统时，basg程序启动，读取配置脚本（_startup files_，定义所
	有用户共享的环境配置）。随后读取home文件夹内的启动文件，配置各用户
	单独环境。读取顺序取决于启用何种shell实例：登陆实例和非登陆实例。

	登陆实例需输入用户名和密码，如虚拟机命令行；非登陆实例通常在图形界
	面环境中使用。

	登陆实例读取下列一个或多个启动文件：
	- /etc/profile：所有用户共享的全局配置脚本。
	- ~/.bash_profile：用户私有启动文件。可用于扩展或重置全局配置。
	- ~/.bash_login：如果不能找到~/.bash_profile文件，bash尝试使用此文
      件代替。
	- ~/.profile：如果~/.bash_profile和~/.bash_login都未找到，bash尝试
      使用此文件代替。Debian类系统如Ubuntu默认使用此文件。

	非登陆实例使用下例2个文件多为启动文件：
	- /etc/bash.bashrc：所有用户共享的全局配置脚本。
	- ~/.bashrc：用户私有启动文件。可用于扩展或重置全局配置。

	除读取上述启动文件外，非登陆实例通常还从其父进程（一般为登陆实例）
	继承环境配置。

	对普通用户而言，~/.bashrc文件始终需读取，所以是最重要的文件。

*** 简单分析启动文件
	下面是~/.profile文件中的内容（Ubuntu）：
	#+BEGIN_EXAMPLE
      # ~/.profile: executed by the command interpreter for login shells.
      # This file is not read by bash(1), if ~/.bash_profile or ~/.bash_login
      # exists.
      # see /usr/share/doc/bash/examples/startufiles for examples.
      # the files are located in the basdoc package.

      # the default umask is set in /etc/profile; for setting the umask
      # for ssh logins, install and configure the libpaumask package.
      #umask 022

      # if running bash
      if [n "$BASH_VERSION" ]; then
          # include .bashrc if it exists
          if [f "$HOME/.bashrc" ]; then
          . "$HOME/.bashrc"
          fi
      fi

      # set PATH so it includes user's private bin directories
      PATH="$HOME/bin:$HOME/.local/bin:$PATH"
	#+END_EXAMPLE

	- #：注释语句
	- if：条件语句的含义为：
	- PATH=...：以ls命令为例，当使用ls命令时，不是直接搜索并执行
      /bin/ls程序，而是根据PATH参数来计算。

*** 修改环境

	*基本规则，如需在PATH中增加文件夹，或者定义额外环境变量，修
	改.bash_profile文件（或等价文件，如Ubuntu中的.profile文件）；其它
	所有修改，更改.bashrc文件。*

	*修改重要文件时，最好先为其保留副本，以免造成系统崩溃。如修
	改.bashrc文件，最好为其新建副本".bashrc.bak"，后缀名易识别即可。*

	备份.bashrc文件：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ cp .bashrc .bashrc.bak
	#+END_EXAMPLE

	在.bashrc文件末添加下列内容：
	#+BEGIN_SRC shelscript
      # 自己修改的内容
      # 只显示隐藏文件和文件夹的别名
      alias l.='lsdF .[!.]color=auto'
	#+END_SRC

	修改后.bashrc文件只有在新的shell实例中生效，如需使其在当前实例中
	生效，可使用source命令：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ source .bashrc
	#+END_EXAMPLE

** vim简介
** 定制shell提示
*** 解析提示字符串
	查看一下命令行提示格式：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ echo $PS1
      # 各系统上差异较大，这里使用简单举例
      \u@\h \W \$
	#+END_EXAMPLE

	PS1变量为"Prompt String 1"的缩写。

	看起来很怪异，实际上大部分是一些特殊字符：

    | \a | ANCII警报。计算机解析到此字符串时发出警报（本机测试失败）。        |
    | \d | 期。格式为"周几 月份 号数"。如"四 8月 25"。                        |
    | \h | 除后缀域名后的，本机主机名。                                       |
    | \H | 整主机名。                                                         |
    | \j | 前shell实例中已有的job数量。                                       |
    | \l | 前命令行设备名称。一般为"0"。                                      |
    | \n | 行字符。                                                           |
    | \r | 车字符。                                                           |
    | \s | Shell程序的名称。一般为"bash"。                                    |
    | \t | 前时间，格式为"时:分:秒"，24小时格式。                             |
    | \T | 前时间，12小时格式。                                               |
    | \@ | 前时间，12小时格式，显示"上午"/"下午"。                            |
    | \A | 前时间，24小时格式，不显示秒数，"时:分"。                          |
    | \u | 前用户名。                                                         |
    | \v | Shell版本号。                                                      |
    | \V | Shell版本和发行号。                                                |
    | \w | 前目录。                                                           |
    | \W | 前目录的最后一部分。                                               |
    | !  | 前命令在命令历史记录里的排序。                                     |
    | #  | 前shell实例中已输入的命令数量                                      |
    | \$ | 果是超级用户显示"$"，否则显示"#"。                                 |
    | [  | 示一个或多个非打印控制字符串的开始。这类字符串可控制光标和颜色等。 |
    | ]  | 一个或多个非打印控制字符串的开始。                                 |

*** 尝试改变提示
	_命令行中的修改只在当前shell实例中有效，请放心使用。_

	将PS1变量缓存，及恢复：
	#+BEGIN_EXAMPLE
      # 缓存到变量ps1_old
      me@ubuntu16.04:~$ ps1_old="$PS1"
      # 查看是否缓存成功
      me@ubuntu16.04:~$ echo $ps1_old
      # 更改PS1变量，立即生效
      me@ubuntu16.04:~$ PS1="....."
      .........
      # 恢复PS1变量默认值
      me@ubuntu16.04:~$ PS1="$ps1_old"
	#+END_EXAMPLE

	使用每条命令开始执行时发出警报（本机测试失败）：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\a\]\$ "
	#+END_EXAMPLE
	使用[和]是因为\a字符并不打印出来。

	使提示信息包含主机名和当前时间：
	#+BEGIN_EXAMPLE
      $ PS1="\A \h \$ "
      16:18 ubuntu16.04 $
	#+END_EXAMPLE

*** 添加颜色
	绝大多数命令行模拟程序都使用非打印字符控制字符属性（如颜色、粗细
	等），以及光标位置。

	将ANSI转义码（ANSI escape code），嵌入到命令模拟器提示字符串中，即
	可实现对命令行模拟器发送指令的功能。ANSI转义码为非打印字符，需置于
	[和]内。

	ANSI转义码以8进制数"033"开头，后为[，后为属性字符（可选），最后为
	指令字符。

	以\033[0;30m]为例，其中\[和;间的0为属性字符，可取值为：
    | 0 | 正常。                 |
    | 1 | 加粗。                 |
    | 4 | 下划线。               |
    | 5 | 闪烁（通常已被禁用）。 |
    | 7 | 反转（inverse）。      |

	下列为表示光标移动的ANSI转义码：
    | 033[0;30m | 黑   | 033[1;30m | 深灰   |
    | 033[0;31m | 红   | 033[1;31m | 浅红   |
    | 033[0;32m | 绿   | 033[1;32m | 浅绿   |
    | 033[0;33m | 棕   | 033[1;33m | 黄     |
    | 033[0;34m | 蓝   | 033[1;34m | 浅蓝   |
    | 033[0;35m | 粉   | 033[1;35m | 浅粉   |
    | 033[0;36m | 蓝绿 | 033[1;36m | 浅蓝绿 |
    | 033[0;37m | 灰白 | 033[1;37m | 白     |

	将提示字符串颜色设置为绿色：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\033[0;32m]\]\A \h \$ "
      ...
	#+END_EXAMPLE

	通过上述设置后，当输入命令时也是设置的颜色。模拟器遇见ANSI转义码时
	开始转换颜色，还原原来颜色需使用转义码\033[0m：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\033[0;32m]\]\A \h \$\[\003[0m\] "
      ...
	#+END_EXAMPLE

	下表为常用背景颜色ANSI转义码（不支持加粗属性，也使用\033[0m还原）：
    | 033[0;40m] | 黑 | 033[0;44m] | 蓝   |
    | 033[0;41m] | 红 | 033[0;45m] | 粉   |
    | 033[0;42m] | 绿 | 033[0;46m] | 蓝绿 |
    | 033[0;43m] | 棕 | 033[0;47m] | 灰白 |

	将提示字符串背景色设置为绿色：
	#+BEGIN_EXAMPLE
      me@ubuntu16.04:~$ PS1="\[\033[0;42m\]\A \h \$\[\033[0;0m\] "
	#+END_EXAMPLE

*** 移动光标
	以PS1 =
	"\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\\]<\u@\h\W>\$"
	，在命令行顶部显示红底黄字的当前时间，为例：

	- \[：标记非打印字符开始。帮助bash计算可见字符串长度。
	- \033[s：缓存当前光标位置。_一些命令行模拟器不能识别此字符。
	- \033[0;0H：将光标置于第一行，第一列。
	- \033[0;41m：将背景色设置为红色。
	- \033[K：从光标处清除到行尾。相当于换行作用，使之前的设置占满整
	  行；_光标位置并不变化_。
	- \033[1;33m：将文本颜色设置为黄色。
	- \t：显示当前时间。虽然这是一个打印字符，为了不使bash计算提示字符
      串实际长度时，将其计算在内，所以仍然包裹在\[\]内。
	- 033m[0m：还原文本和背景色。
	- \033[u：还原已缓存的光标位置。
	- \]：结束非打印转义字符。
	- <\u@\h \W>\$：真正的提示字符串。

	下列为表示光标移动的ANSI转义码：
    | 033[l;cH | 移至l行c列                   |
    | 033[nA   | 向上移动n行                  |
    | 033[nB   | 向下移动n行                  |
    | 033[nC   | 向前移动n个字符位置          |
    | 033[nD   | 向后移动n个字符位置          |
    | 033[2J   | 清屏，并移至左上角（0行0列） |
    | 033[k    | 从当前位置清除到行末         |
    | 033[s    | 缓存光标位置                 |
    | 033[u    | 还原光标位置                 |

*** 保存
	为使设置永久生效，在.bashrc 文件中添加在命令行中一样的复制语句即可：

	#+BEGIN_EXAMPLE
      PS1="\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ "
	#+END_EXAMPLE

* Common Tasks And Essential Tools
** 包管理
   一个linux版本（disttribution）的好坏，取决于 *包管理系统* 和 *社区
   活跃程度* ，因为软件更替速度相当快。

   包管理是指安装和维护软件的方法。如今，基本上所有包都可以从不同版本
   的发行方获取。早期，安装软件下载并编译 *源代码*，此方法只是不太方便，
   需获取系统更高的控制权？。
*** 包管理系统
	不同发行版本有自己的包管理系统，且互不兼容。除Gentoo、 Slackware和
	Arch等外，绝大多数版本分为了2大阵营：Debian的".deb"和Red Hat的
	".rpm"。

    | Debaian风格（.deb）  | Debain、Ubuntu、Linux Mint、Raspbian               |
    | Read Hat风格（.rpm） | Fedora、CentOS、Red Hat Enterprise Linux、OpenSUSE |

*** 包管理系统如何工作
	Linux所有的安装包都可通过网路获取。存在方式有2中：绝大多数由版本供
	应商以_包文件_的形式提供；其余部分为需手动安装的源代码。

*** 常用的包管理任务
**** 从项目中寻找包
	 使用高级包管理工具可通过包名和关键字，在仓库元数据中搜索对应包。

	 包搜索命令：
     | Debian  | apt search /名称或关键字/ |
     | Red Hat | yum search /名称或关键字/ |

	 比如在Ubuntu中搜索"emacs"编辑器：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ apt search emacsw
	 #+END_EXAMPLE

**** 从项目中安装包
	 使用高级包管理工具，可从仓库下载一个包并安装，同时还可解决依赖问
	 题。

	 包安装命令：

	 | Debian  | apt install /名称或关键字/ |
	 | Red Hat | yum install /名称或关键字/ |

	 比如在Ubuntu中安装"emacs"编辑器：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ apt install emacs
	 #+END_EXAMPLE

**** 用文件安装包
	 如果是下载的源码，需使用低级包管理工具安装。但不能自动解决依赖问
	 题，依赖缺失时会报错。低级包管理工具对应命令：

     | Debain  | dpkg --install /已下载的文件名/ |
     | Red Hat | rmp -i /已下载的文件名/         |

	 以Ubuntu安装搜狗拼音为例
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ dpkg --install sogoupinyin_2.0.0.0078_amd64.deb
	 #+END_EXAMPLE

**** 卸载包
	 高级和低级包管理工具都可卸载包。原则为高级工具卸载高级工具安装的
	 包，低级工具卸载低级工具安装的包。

     | Debain  | apt remove _包名_ | dpkg --remove _包名_ |
     | Red Hat | yum erase _包名_  | ?                    |

	 卸载emacs：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ apt remove emacs
	 #+END_EXAMPLE

**** 更新包
	 包管理工具最重要的任务就是跟新所有安装包，只需一个命令就可实现：

     | Debian   | apt update;apt upgrade |
     | Red Hate | yum upgrade            |

	 如果是使用低级包管理工具安装的包，Debian中只有重新安装，实现更新；
	 Red Hat中则可使用`rpm`命令的"-U"选项：

     | Debian  | dpkg --install /需要跟新的包对应的新下载文件/ |
     | Red Hat | rpm -U /需要跟新的包对应的新下载文件/         |

**** 列出所有已安装包
     | Debian  | dpkg --list |
     | Red Hat | rpm -qa     |
**** 查看一个包是否已安装
     | Debian  | dpkg --status /包名/ |
     | Red Hat | rpm -q /包名/        |

**** 查看一个已安装包的描述信息
     | Debian  | apt-cache show _包名_ |
     | Red Hat | yum info _包名_       |

**** 查看已安装包的安装文件
	 查看包安装后，写入了哪些文件？：

     | Debian  | dpkg --search _包名/关键字_ |
     | Red Hat | rpm -df _包名/关键字_       |

** 存储设备
   以往章节都是以文件为单位讨论数据处理，本节以设备为单位讨论数据处理。
   不管是物理存储设备，如硬盘和网络连接存储（nerwork storage）；还是虚
   拟存储设备，如磁盘阵列（Redundant Arrays of Independent Disks，RAID）
   和逻辑卷管理（Logical Volume Manager，LVM），Linux都有出色的处理能
   力。

   学习本节需要的设备有可擦写光盘（CD-RW）、U盘（usb flash drive）和软
   盘（floppy disk）。

   - *mount* ：挂载文件系统。
   - *umount* ：对文件系统解除挂载
   - *fsck* ：检测和修复文件系统
   - *fdisk* ：磁盘分区表操作（Partition table manipulator）
   - *mkfs* ：创建文件系统
   - *dd* ：将设备型文件直接写入设备
   - *fdformat* ：格式化软盘
   - *genisoimage（mkisofs）* ：创建一个ISO镜像文件
   - *wodim（cdrecord）* ：将数据写入存储介质（optical storage media）
   - *md5sum* ：计算MD5值

*** 挂载和取消挂载存储设备
	操作存储设备，首先需将其添加到文件系统树上，成为操作系统的一部分。
	此过程即称为“挂载”。

	在桌面系统上，存储设备会自带挂载。以Ubuntu16.04为例，U盘和光盘会自
	带挂载到“/media/用户名”目录下，安卓手机会挂载到“/run/user/用户名ID
	（一般为1000）/gvfs”目录下。 _在服务器上，则需手动挂载。_

	/etc/fstab（“file system tabe”的缩写）文件中包含所有系统启动时就挂
	载的设备（一般为硬盘分区）：
	#+BEGIN_EXAMPLE
      # <file system> <mount point>   <type>  <options>       <dump>  <pass>
      # / was on /dev/sda1 during installation
      UUID=2b59c6b3-ced1-4535-a730-095092943a66 /               ext4    errors=remount-ro 0       1
      # /home was on /dev/sda6 during installation
      UUID=796f3a21-35bd-48c8-9b53-bb6214a0a50b /home           ext4    defaults        0       2
      # swap was on /dev/sda5 during installation
      UUID=34cc34a6-139d-45da-aea8-94924140285e none            swap    sw              0       0
	#+END_EXAMPLE

	各列的含义分别为：

	1. 设备名（文件系统，file system）。传统情况下为系统中物理设备的
       真实名字，如dev/sda1（第一个硬盘上的第一个分区）。不过现今一般
       使用标签（label）表示，标签可以是纯文本或UUID（如上）。当设备
       连接系统时，系统读取此标签。
	2. 挂载点（mount point）。设备在系统文件树上对应的位置。
	3. 文件类型（type）。绝大多数Linux系统使用ext4（第四代扩展文件系
       统，Fourth Extended File System），不过也支持FAT16 (msdos)、
       FAT32 (vfat)、 NTFS (ntfs)和CD-ROM (iso9660)等。
	4. 挂载选项（options）。文件系统可使用多种挂载选项。比如，可挂载为
       只读，防止在内执行程序？（可提高移动设备的安全性）。
	5. 备份（dump）。使用dump命令备份时，指定是否接受备份，以及何时备
       份。
	6. 检测/修复（pass）。使用fsck检测和修复时的执行顺序。

**** 查看已挂载的文件系统
	 使用mount命令，不带任何参数，可查看当前已挂载的所有文件系统：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mount
       /dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)
       securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relat
       ime)
       tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
       tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
       tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
       ...
       /dev/sdb1 on /media/me/disk type vfat (rw,nosuid,nodev,relatime,uid=1000,gid=1000,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)
	 #+END_EXAMPLE

	 输出内容的格式为：“设备名 on 挂载点 type 文件类型（挂载选项）”。
	 比如第一行的含义为，/dev/sda1设备挂载到根目录上，文件格式为ext4，
	 可读可写（“rw”）。

	 为测试，插入一张可读写光盘后，重新执行mount命令会新增如下内容：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ mount | less
       ...
       /dev/sr0 on /media/me/e-STUDIO Client type iso9660 (ro,nosuid,nodev,relatime,uid=1000,gid=1000,iocharset=utf8,mode=0400,dmode=0500,uhelper=udisks2)
       ...
	 #+END_EXAMPLE

	 上例表示，光盘设备在系统中的设备名为/dev/sr0，挂载点为
	 /media/me/e-STUDIO Client。

	 取消挂载光盘：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ ls /media/me #可见光盘中内容
       e-STUDIO Client
       me@ubuntu16.04:~$ sudo umount /dev/sr0
       me@ubuntu16.04:~$ ls /media/me
       # 表示光盘的文件夹消失，表示取消挂载成功
	 #+END_EXAMPLE

	 为光盘新建一个挂载点，使用-t选项表示文件类型：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ sudo mkdir /mnt/cdrom # 新建文件夹
       # 将光盘挂载到新建的文件夹上，iso9660为光盘的文件格式
       me@ubuntu16.04:~$ sudo mount -t iso9660 /dev/sr0 /mnt/cdrom
       me@ubuntu16.04:~$ ls /mnt/cdrom
       ... #出现光盘内容，表示挂载成功
       me@ubuntu16.04:~$ sudo umount /dev/sr0 #再次取消挂载
       me@ubuntu16.04:~$ ls /mnt/cdrom
       # 无任何内容，取消挂载成功
	 #+END_EXAMPLE

**** 判断设备名称
	 在桌面系统中，设备自动挂载后可使用mount命令查看其在系统系统中的名
	 称；但是，在不支持自动挂载的环境中（如服务器），则需要通过查看
	 /dev文件夹来确定设备在系统中对应的名称。/dev文件夹包含了系统中所
	 有设备（为何安卓手机设备不包含？）。

	 不同类型设备有特定的命名规则：

	 - fd*：软盘。

	 - hd*：老式系统中的IDE硬盘（IDE即Integrated Drive Electronics）。
       尤其是指主板有2个IED管道/接口（channels/connectors），每个接口
       都由一 根有2个附着点的线路链接的硬盘？？。线路上的第一个硬盘称
       为主设备， 第二个称为奴设备。命名规则为，/dev/hda表示第一个管道
       上的主设备， /dev/hdb表示第一个管道上的奴设备；/dev/hdc表示第二
       个管道上的主设备。 以此类推。名称后所跟数字表示在设备上的分区号，
       比如/dev/hda1表示第 一个硬盘上的第一个分区，/dev/hda表示整个硬
       盘。

	 - /dev/lp*：打印机。

	 - /dev/sd_：SCSI硬盘（是采用SCSI接口的硬盘，SCSI是Small Computer
       System Interface”小型计算机系统接口“”的缩写，使用50针接口，外观
       和普通硬盘接口有些相似）。在现代Linux系统中，内核将所有
       disk-like设备（包括PATA/SATA硬盘、U盘、如mp3/4这样的USB大型存储
       设备和数码相机）都视为SCSI硬盘。命名的后半部分和/dev/hd_设备规
       则相同。

	 - /dev/sr*：光驱（CD/DVD读取机/刻录机）。

	 在不自动挂载移动设备的环境中，可使用tail命令实时查看系统日志来判
	 断设备名称：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ sudo tail -f /var/log/syslog
	 #+END_EXAMPLE

	 以插入U盘为例，当插入U盘后，会出现类似如下的类容：
	 #+BEGIN_EXAMPLE
       ...
       Aug 27 21:27:42 me kernel: [14505.508766]  sdb: sdb1
       Aug 27 21:27:42 me kernel: [14505.509862] sd 8:0:0:0: [sdb] Attached SCSI removable disk
       ...
	 #+END_EXAMPLE

	 通过上面结果可知，U盘对应的系统设备名称为/dev/sdb，/dev/sdb1为其
	 第一分区。

	 得知设备在系统上对应的名称后，就可将其挂载到文件树上：
	 #+BEGIN_EXAMPLE
       me@ubuntu16.04:~$ sudo mkdir /mnt/flash
       me@ubuntu16.04:~$ sudo mount /dev/sdb1 /mnt/flash
       me@ubuntu16.04:~$ df -h #使用df命令查看所有文件系统使用情况
       ...
       /dev/sdb1        14G  548M   14G   4% /media/me/disk
       # /dev/sr0        594M  594M     0 100% /media/me/e-STUDIO Client
	 me@ubuntu16.04:~$
	 #+END_EXAMPLE

	 *重启前，挂载的设备会一直有效。*

*** 创建新的文件系统
	比如要将U盘原有的FAT32文件系统格式化为Linux本地文件系统，需2步：
	1. （可选）修改分区。
	2. 在U盘上创建新的空文件系统。

**** 使用fdisk命令对设备分区
	 以对U盘分区为例。首先需去挂载：
	 #+BEGIN_EXAMPLE
       sudo unmount /dev/sdb1
       sudo fdisk /dev/sdb
	 #+END_EXAMPLE

	 *注意：使用fdisk操作设备时需使用整个设备，而不是单个分区。*

	 程序启动后进入交换页面：
	 #+BEGIN_EXAMPLE
       Command (m for help):
	 #+END_EXAMPLE

	 使用m命令可查看所有可执行的命令：
     | a |                                             |
     | b |                                             |
     | c |                                             |
     | d | 删除一个分区                                |
     | l | 列出所有有效的分区文件系统                  |
     | m |                                             |
     | n | 新建一个分区                                |
     | o |                                             |
     | p | 打印当前的分区情况                          |
     | q | 不执行修改，退出                            |
     | s |                                             |
     | t | 改变设备的文件系统，从l命令中获取的ID中选择 |
     | u |                                             |
     | v |                                             |
     | w | 确认更改，写入，并退出                      |
     | x |                                             |

	 首先使用p命令查看当前的分区情况：
	 #+BEGIN_EXAMPLE
       Disk /dev/sdb: 16 MB, 16006656 bytes
       1 heads, 31 sectors/track, 1008 cylinders
       Units = cylinders of 31 * 512 = 15872 bytes
             Device      Boot   Start    End     Blocks    Id  System
          /dev/sdb1             2        1008    15608+    b   W95 FAT32
	 #+END_EXAMPLE

	 可见，U盘设备为16MB，有1个分区（/dev/sdb1），使用了1008个扇面
	 （cylinders）中的1006个（End - Start）。Id项显示的为格式化系统类
	 型对应的编号（b），System则是其相应的名称。

	 下面通过l命令查看可选格式化类型。

	 使用t命令开始修改，选中83对应的Linux文件系统，最后执行w命令确认并
	 退出。（如果不使用w命令，可使用q命令放弃所有修改并退出）
**** 使用mksf创建新的文件系统
	 对设备分区后，可使用mksf命令为各分区创建新的文件系统。使用-t参数
	 指定文件系统类型，如：
	 #+BEGIN_EXAMPLE
       sudo mkfs -t ext4 /dev/sdb1
	 #+END_EXAMPLE

	 如需改回原有的FAT32文件系统，可使用vfat参数值指定：
	 #+BEGIN_EXAMPLE
       sudo mkfs -t vfat /dev/sdb1
	 #+END_EXAMPLE

*** 测试和修复文件系统
	系统启动时，会自动执行fsck命令检查文件（对应设备），文件/etc/fstab
	中最后一项为检查顺序。如果有错误，系统会停止启动。

	此外fsck命令还可用于检查指定设备：
	#+BEGIN_EXAMPLE
      sudo fsck /dev/sdb1
	#+END_EXAMPLE

*** 格式化软盘
*** 直接从设备上写入和读取数据
	需使用dd命令，一般格式为：
	#+BEGIN_EXAMPLE
      dd if=input_file of=output_file [bs=block_size [count=blocks]]
	#+END_EXAMPLE

	*dd命令会提前清空目标文件中的所有内容。*

	比如有2个U盘，挂载点分别为/dev/sdb和dev/sdc，将前一个U盘中的内容写
	入后一个的命令为：
	#+BEGIN_EXAMPLE
      dd if=/dev/sdb of=/dev/sdc
	#+END_EXAMPLE

	或者可以将设备中的所有文件复制到本地：
	#+BEGIN_EXAMPLE
      dd if=/dev/sdb of=flash_drive.img
	#+END_EXAMPLE

*** 创建CD_ROM镜像文件
	向光盘写入镜像文件分2步：
	1. 创建与光盘文件系统相同的镜像文件。
	2. 向光盘写入已有的镜像文件。

**** 利用光盘创建镜像文件
	 将光盘拷贝到本地备用，以将Ubuntu镜像光盘为例：
	 #+BEGIN_EXAMPLE
       dd if=/dev/cdrom of=ubuntu.iso
	 #+END_EXAMPLE

**** 利用本地文件创建镜像文件
	 以将文件夹~/cd-rom-files中的文件夹复制到镜像文件cd-rom.iso为例：
	 #+BEGIN_EXAMPLE
       genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
	 #+END_EXAMPLE

*** 写入CD_ROM镜像文件
	有了镜像文件后，就可将其写入光盘等介质。
**** 直接挂载镜像文件
	 结合"-o loop"参数（以及-t iso9660参数）可将本地镜像文件像设备一样
	 挂载到文件树上，以已有的image.iso镜像文件为例：
	 #+BEGIN_EXAMPLE
       mkdir /mnt/iso_image
       mount -t iso9660 -o loop image.iso /mnt/iso_image
	 #+END_EXAMPLE

**** 清空可重写的CD-ROM
	 使用wodim命令可清空一个可写的CD-ROM，blank参数表示执行速度：
	 #+BEGIN_EXAMPLE
       wodim dev=/dev/cdrw blank=fast
	 #+END_EXAMPLE
**** 写入镜像文件
	 写入镜像文件也是使用wodim命令：
	 #+BEGIN_EXAMPLE
       wodim dev=/dev/cdrw image.iso
	 #+END_EXAMPLE

	 除dev参数外，还可设置-v参数提供verbose输出，以及用于商业保护的-dao参
	 数，还有-tao参数（track-at-once）。

*** md5sum
	使用md5sum命令可查看iso文件和光盘介质的大小验证值：

	检查iso文件的值：
	#+BEGIN_EXAMPLE
      md5sum image.iso
      34e354760f9bb7fbf85c96f6a3f94ece image.iso
	#+END_EXAMPLE

	检查光盘介质的值：
	#+BEGIN_EXAMPLE
      md5sum /dev/cdrom
      34e354760f9bb7fbf85c96f6a3f94ece /dev/cdrom
	#+END_EXAMPLE

** 网络
   - *ping* ：向一个网络主机发生ICMP ECHO_REQUEST。
   - *traceroute* ：
   - *ip* ：
   - *netstat* ：
   - *ftp* ：传输网络文件。
   - *wget* ：非交互式网络下载工具。
   - *ssh* ：OpenSSH SSH客户端（远程登录程序）。

*** 网络检查和侦测
**** ping
	 使用ping命令可向指定主机发送ICMP ECHO_REQUEST特殊请求（有的服务器
	 可通过配置忽视此请求）。

	 #+BEGIN_EXAMPLE
       ping bing.com
	 #+END_EXAMPLE

	 使用C-c结束命令后，如果网络正常，会显示0% packet loss。

**** traceroute
	 显示访问指定主机需经过的网路：

	 #+BEGIN_EXAMPLE
       traceroute bing.com
       traceroute to bing.com (13.107.21.200), 30 hops max, 60 byte packets
           1  gateway (192.168.43.1)  2.094 ms  2.061 ms  2.096 ms
           2  * 10.231.0.1 (10.231.0.1)  133.445 ms  133.570 ms
           3  192.168.183.209 (192.168.183.209)  144.619 ms  144.832 ms  144.783 ms
           4  192.168.52.245 (192.168.52.245)  144.760 ms  144.735 ms  144.718 ms
           5  183.221.32.13 (183.221.32.13)  146.757 ms  146.897 ms  146.896 ms
	 #+END_EXAMPLE

	 从上例可看出，本机访问bing.com需经过5个网路。如果路由提供身份信息，
	 可见其主机名、IP地址及性能数据；如果不提供则为星号。

**** ip
	 ip命令是一个多功能的网路配置工具，可完全利用现代Linux内核的网络功
	 能。（是已废弃命令ifconfig的替代）

	 如检查网络接口和"路由表（routing table）"：
	 #+BEGIN_EXAMPLE
       1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN
       group default
             link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
             inet 127.0.0.1/8 scope host lo
                  valid_lft forever preferred_lft forever
             inet6 ::1/128 scope host
                   valid_lft forever preferred_lft forever
       2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast
       state UP group default qlen 1000
             link/ether ac:22:0b:52:cf:84 brd ff:ff:ff:ff:ff:ff
             inet 192.168.1.14/24 brd 192.168.1.255 scope global eth0
                  valid_lft forever preferred_lft forever
             inet6 fe80::ae22:bff:fe52:cf84/64 scope link
                   valid_lft forever preferred_lft forever
	 #+END_EXAMPLE

	 从上面的结果可看出，测试系统有2个网络接口：
	 1. lo (loopback interface)：系统用于与自己交流的虚拟接口。
	 2. eth0(Ethernet interface)：以太网接口。

	 在日常网络检测时的判断方法为：
	 1. 每个接口第一行的"UP"表示接口成功连接。
     2. “inet”项有正确的ip地址。如果使用的是DHCP(Dynamic Host
        Configuration Protocol)，有效的IP地址表示DHCP正在工作。

**** netstat
	 netstat程序可查看许多网络配置和静态数据。使用"-ie"参数可查看本地
	 网络接口（结果同"ip a"命令）。

	 使用"-r"参数可显示内核的"路由表"，即显示网络间发送数据包是怎样配
	 置的：

	 #+BEGIN_EXAMPLE
       Kernel IP routing table
       Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
       default         gateway         0.0.0.0         UG        0 0          0 wlan0
       192.168.1.0    0.0.0.0         255.255.255.0   U         0 0          0 wlan0
	 #+END_EXAMPLE

	 其他参数：
     | -a     | 显示所有正监听和没监听的线程 |
     | -l     | 仅显示正在监听的线程         |
     | -p     | 显示线程所属的程序PID        |
     | 。。。 |                              |

*** 文件传输
**** ftp
	 以在ftp.cn.debian.org服务器上下载文件为例：
	 #+BEGIN_EXAMPLE
       ftp ftp.cn.debian.org
	 #+END_EXAMPLE

	 密码为"anonymous"，密码可不填。可使用的命令有：
	 - ls：列出资源
	 - cd：文件夹跳转
	 - lcd：本地文件夹跳转
	 - get：下载指定文件
	 - bye：退出ftp程序
**** wget
	 支持http、ftp和https协议。可下载ftp文件，也可抓取网页（可递归抓取
	 整个网页，使用"-r"参数）。如抓取bing的首页：
	 #+BEGIN_EXAMPLE
       wget bing.com
	 #+END_EXAMPLE

*** 远程安全交流
	shh程序解决了rlogin和telnet两个程序的安全型问题。上2个程序同ftp程
	序一样，传输所有内容（用户名和密码）时都用纯文本。
**** ssh（Secure Shell）
	 ssh程序解决安全问题的办法是：
	 1. 远程主机需授权。
	 2. 加密传输内容。

	 SSH由两部分组成：SHH远程服务器上一直监听连接的22端口，连接远程主
	 机的SSH客户端。（登录时可使用-p参数指定端口。）

	 如需接受远程SSH连接，需安装openssh-server程序，且打开22端口接受连
	 接。

	 以远程主机remote-sys为例，ssh登录的命令为：
	 #+BEGIN_EXAMPLE
       ssh remote-sys
	 #+END_EXAMPLE

	 登录后，直到执行exit命令，才返回本地命令行。

	 登录时如果远程主机用户名与当前用户名不同，也可指定用户名，如果有
	 在remote-sys上的用户名bob，登录形式为：

	 #+BEGIN_EXAMPLE
       ssh bob@remote-sys
	 #+END_EXAMPLE

	 还可使用ssh程序在远程主机上执行单个命令：
	 #+BEGIN_EXAMPLE
       ssh remote-sys free
	 #+END_EXAMPLE

	 甚至可将在远程和本地重定向文件：
	 #+BEGIN_EXAMPLE
       ssh remote-sys 'ls *' > dirlist.txt
	 #+END_EXAMPLE

	 注意上例使用了单引号，目的是为了星号在远程主机上执行时膨胀，而不
	 是本地。
**** scp和sftp
	 OpenSSH包含2个利用SSH机密机制传输文件的程序：
	 1. scp (secure copy)。如复制remote-sys主机上home目录下的
        document.txt文件到当前目录：
		#+BEGIN_EXAMPLE
          scp remote-sys:document.txt .
		#+END_EXAMPLE

		也可指定用户名：
		#+BEGIN_EXAMPLE
          scp bob@remote-sys:document.txt .
		#+END_EXAMPLE

	 2. sftp。与ftp程序极相似，使用方法也一样。不过使用的是SSH加密通道，
        并且远程主机不需开启ftp服务。

** 文件查找
   - *locate* ：通过名称查找文件
   - *find* ：在指定文件夹下查找文件
   - *xargs* ：利用标准输入流构建命令
   - *touch* ：改变文件时间状态
   - *stat* ：显示文件或文件系统静态信息
*** locate - 简单的文件查找工具
	locate会搜索系统内包含指定字符串的文件，如已知所有程序文件都在bin
	目录下，搜索有zip关键字的程序命令为：
	#+BEGIN_EXAMPLE
      locate bin/zip
	#+END_EXAMPLE

	复杂搜着可结合其他工具使用如grep：
	#+BEGIN_EXAMPLE
      locate zip | grep bin
	#+END_EXAMPLE

	如需使用正则匹配，可使用--regexp参数：
	#+BEGIN_EXAMPLE
      locate --regexp "html$" | grep home
	#+END_EXAMPLE

	locate查找文件依赖的是系统数据库，该数据库由updatedb程序创建，默认
	每天执行一次，所有新创建的文件无法找到，可收到执行updatedb程序将新
	创建的文件写入数据库。

*** find - 复杂的文件查找工具
	与locate程序不同，find程序需指定文件夹，再更加各种属性查找，且不依
	赖数据库。比如查看home目录下有多少个文件：
	#+BEGIN_EXAMPLE
      find ~ | wc -l
	#+END_EXAMPLE

**** 过滤参数
	 - 文件类型过滤，使用-type参数。如只查找文件夹：
	   #+BEGIN_EXAMPLE
         find ~ -type -d | wc -l
	   #+END_EXAMPLE

	   只查找文件：
	   #+BEGIN_EXAMPLE
         find ~ -type f | wc -l
	   #+END_EXAMPLE

	   可过滤的文件类型选项有：
       | b | 块设备文件     |
       | c | 字符型设备文件 |
       | d | 文件夹         |
       | f | 一般文件       |
       | l | 软链接         |

	 - 文件名过滤，使用-name参数。如结果中只包含png文件：
	   #+BEGIN_EXAMPLE
         find ~ -type -f -name ".png"
	   #+END_EXAMPLE

	 - 文件大小过滤，使用-size参数。如查找大小大于1Mb的png文件：
	   #+BEGIN_EXAMPLE
         find ~ -type -f -name "*.png" -size +1M
	   #+END_EXAMPLE

	   其他表示大小的符号为：
       | b | 512byte，如过没指定符号，为默认 |
       | c | byte                            |
       | w | 2-byte                          |
       | K | kb                              |
       | M | Mb                              |
       | G | 1024Mb                          |

	   其中加号和减号表示大于和小于该值，如果省略表示为精确值。

	 - 其他常用过滤参数：
       | -cmin n        | n分钟前内容或属性修改的文件（精确值）        |
       | -cnewer file   | 内容或属性比file后修改过的文件               |
       | -ctime n       | n*24小时前修改内容或属性的文件               |
       | -empty         | 空文件                                       |
       | -group name    | group属于name（名称或ID）的文件              |
       | -iname pattern | -name参数的不区分大小写版本                  |
       | -inum n        | inode值为n的文件，对查找硬链接文件很有用     |
       | -mmin n        | 仅内容n分钟前修改的文件                      |
       | -mtime n       | 仅内容n*24小时前修改过的文件                 |
       | -newer file    | 仅内容比file后修改的文件。可用于文件backup。 |
       | -nouser        | 不属于任何用户的文件。可用于清除攻击文件。   |
       | -nogroup       | 不属于某用户组的文件                         |
       | -perm mode     | 权限为mode（可为8进制数或符号）的文件        |
       | -samefile name | 与-inum相似。与name文件有相同inode值的文件   |
       | -user name     | 属于name用户的文件                           |

**** 逻辑判断
	 以查找home目录下权限不为0600的文件，或权限不为0700的文件夹为例：
	 #+BEGIN_SRC shell-script
       find ~ \( -type f -not -perm 0600 \) -or \( -type f -not -perm -0700 \)
	 #+END_SRC

	 逻辑判断符有：
     | -or  | 或 |
     | -and | 且 |
     | -not | 非 |

	 使用括号分组，由于括号有特殊含义需转义。

**** 内置操作
	 完成搜索操作后，find程序定义了一些直接操作的参数：
     | -delete | 删除搜索结果                     |
     | -ls     | 使用相当于ls -dils的命令列出结果 |
     | -print  | 打印结果的绝对路径。（默认行为） |
     | -quit   | 一找到结果就退出                 |

**** 定制操作
	 执行定制命令的格式为：
	 #+BEGIN_EXAMPLE
       -exec 命令 {} ;
	 #+END_EXAMPLE
	 其中命令为需对搜索结果执行的命令。由于大括号和分号有特殊含义，需
	 用引号包裹，如对搜索结果执行ls命令：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.txt" -exec ls '{}' ';'
	 #+END_SRC

	 花括号实际上表示的就是搜索结果。

	 也可用-ok替代-exec，这样每次执行命令时都会询问：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.txt" -ok ls '{}' ';'
	 #+END_SRC

**** 提高操作效率
	 使用-exec执行定制命令时，实际上会对搜索结果的每条分别执行命令，如
	 需将结果作为整体执行命令，可将分号换为加号（无需引号包裹）：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.txt" -exec ls '{}' +
	 #+END_SRC

**** xargs
	 xargs程序可将标准输入流转换为多个参数（an argument list）供其它命
	 令使用。

	 如将find的结果通过管道传递给xargs，再传递给其它程序：
	 #+BEGIN_SRC shell-script
       find ~ -type f -name "*.html" | xargs ls -l
	 #+END_SRC

	 由于Unix系统允许文件名中含空格（甚至是换行符）。对于此情况可在
	 find程序执行时使用-print0控制输出，使用xargs时再配合--null参数使
	 用：
	 #+BEGIN_SRC shell-script
       find ~ -iname "*.png" -print0 | xargs --null ls
	 #+END_SRC

**** 其它一些常用的参数
     | -depth           | 搜索深度。如果有-delete操作会自动使用此参数                          |
     | -maxdepth levels | 最大搜索深度。传递至以后的测试和操作                                 |
     | -mindepth levels | 最小搜索深度。传递至以后的测试和操作                                 |
     | -mount           | 不搜索挂载到其它文件系统下的文件                                     |
     | -noleaf          | 让搜索过程不假设是在Unix环境而进行优化，对搜索Windos和CD-ROM文件有用 |

** 归档和备份
   - *gzip* ：压缩/解压文件。
   - *bzip2* ：“块排序（block sort）”文件压缩程序
   - *tar* ：“磁带归档（tape archiving）”应用
   - *zip* ：打包和压缩文件
   - *rsync* ：远程同步文件
*** 压缩
	压缩分有损和无损2种，有损压缩一般应用于图片和音乐文件，系统管理时
	一般使用无损压缩，所以本章介绍的压缩全是无损压缩。
**** gzip
	 gzip可压缩多个文件，压缩后的文件会替换掉原来的文件。对应的解压程
	 序为gunzip。
	 #+BEGIN_EXAMPLE
       gzip emma.txt
       gunzip emma.txt.gz
	 #+END_EXAMPLE

	 压缩后的文件名会在原文件名的基础上添加“.gz”后缀。且压缩后权限和时
	 间状态不会修改。

	 下面为gzip的一些常用参数：
     | -c    | --stdout 或 --to-stdout      | 保留原文件，将压缩结果输出到标准输出流 |
     | -d    | --decompress 或 --uncompress | 解压，相当于gunzip                     |
     | -f    | --force                      | 即使已存在文件的压缩文件，仍强制压缩   |
     | -h    | --help                       | 使用帮助                               |
     | -l    | --list                       | 显示压缩文件的压缩信息                 |
     | -r    | --recursive                  | 如果是文件夹，递归压缩                 |
     | -t    | --test                       | 测试已压缩文件的兼容性                 |
     | -v    | --verbose                    |                                        |
     | -数字 | 1到9（默认为6）              | 压缩程度                               |
	 使用“-数字”参数时，1和9分别可以--fast和--best替换。

	 gzip还可从标准输入流中获取文本压缩：
	 #+BEGIN_SRC shell-script
       ls -l /etc | gzip foo.txt.gz
	 #+END_SRC

	 如果需查看压缩文件，可将gunzip程序配合-c参数使用：
	 #+BEGIN_SRC shell-script
       gunzip -c foo.txt.gz | less
	 #+END_SRC

	 也可使用gzip对应的cat版本zcat：
	 #+BEGIN_SRC shell-script
       zcat foo.txt.gz
	 #+END_SRC

	 还可使用zless程序：
	 #+BEGIN_SRC shell-script
       zless foo.txt.gz
	 #+END_SRC
**** bzip2
	 bzip2程序的功能和使用参数基本上和gzip程序一样，使用了不同的算法，
	 压缩率更高，不过压缩速度不如gzip。

	 压缩文件添加的文件后缀名为“.bz2”。

	 对应的解压程序为bunzip2，压缩文件查看程序为bzcat。

	 还附带了bzip2recover程序，可尝试恢复损坏的.bz2文件。

*** 归档
	通常与文件压缩结合使用的时文件归档操作。归档可将多个文件绑定到一个
	大文件中，一般用于系统备份，或者将旧数据打包后转移到长期存储设备上。
**** tar
	 tar为“tap archive”的缩写，可见是Unix系统中历史悠久且经典的文件打
	 包命令。

	 压缩后的文件后缀为.tar，如果是.tgz则表示经过gzip程序压缩。

	 tar命令的参数成为mode（模式），参数前不带"-"符号。常用的一些模式
	 如下：
     | f | 指定生成文件/目标提取文件 |
     | c | 创建文件包                |
     | x | 提取文件包                |
     | r | 向文件包追加文件          |
     | t | 列出文件包中的文件        |

	 与gzip和bzip2结合使用的模式：
     | z | --gzip 或--gunzip或ungzip | 归档后使用gzip压缩文件包，或提取前使用gzip/gunzip解压 |
     | j | --bzip2                   | 归档后使用bzip2压缩文件包，或提取前使用bzip2/bunzip2解压 |

	 由于历史原因，tar命令使用与一般命令有不同之处，下面举例展示其使用
	 方法。首先创建一个测试文件夹：
	 #+BEGIN_SRC shell-script
       mkdir -p playground/dir-{001..100}
       touch playgrpund/dir-{001..100}/file-{A..Z}
	 #+END_SRC

	 mkdir的-p参数为如果父文件夹不存在，先创建父文件夹。

	 将整个playground文件夹打包：
	 #+BEGIN_SRC shell-script
       tar cf playground.tar playground
	 #+END_SRC

	 tar命令除参数无需-符号外，参数还必须放在最前。

	 列出文件夹使用tf模式，如需详细信息可添加v模式：
	 #+BEGIN_SRC shell-script
       tar tvf playground.tar
	 #+END_SRC

***** 路径问题（没怎么理解）
	  下面将归档文件在新的文件夹中提取：
	  #+BEGIN_SRC shell-script
        mkdir foo
        cd foo
        tar xf playground ../playground
	  #+END_SRC

	  查看foo文件夹可见，提取后的playground文件夹，其中的文件结构与原
	  来的文件夹完全相同。

	  除超级用户外，提取后文件的所有权为执行提取的用户。

	  tar归档文件时采用的是相对路径（即去除原文件名绝对路径前的斜杠）。
	  下面用另一种方式归档文件，再在foo文件夹中提取：
	  #+BEGIN_SRC shell-script
        tar cfv playground2.tar ~/playground
        cd foo
        tar xvf ../playground2.tar
	  #+END_SRC

	  现在在foo文件夹中就会生成home目录，提取后的playground文件夹依然
	  在里面。原有在于"~/playground"文件名会膨胀为
	  “/home/claudio/playground”。

	  #+BEGIN_QUOTE
	  此节不怎么理解。到目前为止的理解是，如果要在提取文件后文件都为绝
	  对路径，打包时就都应该使用绝对路径。
	  #+END_QUOTE

	  比如使用U盘将一台电脑上的home目录复制到另一台电脑：
	  #+BEGIN_SRC shell-script
        sudo tar cfv /media/U盘/home.tar /home
        # 另一台电脑上的操作：
        cd /
        sudo tar xfv /media/U盘/home.tar
	  #+END_SRC
	  这里假设U盘挂载到了/media文件夹中的"U盘"文件夹上。需注意的是，提
	  取前需将当前目录cd到根目录下。

***** 提取单个文件
	  在提取命令后添加文件名（路径需与打包文件中的路径完全相同），可实
	  现提取一个或多个文件。

	  如需支持wildcard还需结合--wildcards参数使用：
	  #+BEGIN_SRC shell-script
        tar xf ../playground2.tar --wildcards 'home/me/playground/dir-*/file-A'
	  #+END_SRC

***** 结合find使用
	  结合find使用可将一系列匹配的文件打包：
	  #+BEGIN_SRC shell-script
        find playground -name 'file-A' exec tar rf playground.tar '{}' '+'
        # 或者
        find playground -name 'file-A' | xargs tar rf playground.tar
	  #+END_SRC

	  使用此功能可通过timestamp文件，通过find命令的-newer参数不断备份
	  文件。

	  tar程序还可使用标准输入和输出流，如将find的结果归档后再压缩：
	  #+BEGIN_SRC shell-script
        find playground -type f -name 'file-A' | tar cf - --files-from=- | gzip > playgroundA.tgz
	  #+END_SRC

	  tar命令中的2个“-”表示标准输出/入流，会根据情况自动识别为标准输出
	  流还是标准输入流。（“-”号的此用法在其他很多和程序中还会用到）。
	  所以第一个"-"表示的是标准输出流，--files-from的值的“-”则是表示的
	  标准输入流（--from-files= - 还可用-T - 替代）。

	  经过gzip压缩后的打包文件后缀一般是.tgz，有时也用.tar.gz。

	  在tar命令中使用z或j模式，可将打包后的文件再经gzip或bzip2程序压缩：
	  #+BEGIN_SRC shell-script
        # 打包后使用gzip压缩
        find playground -type f -name 'file-A' | tar cfz playground.tgz -T -
        # 打包后使用bzip2压缩
        find playground -type f -name 'file-A' | tar cfj playground.tbz -T -
	  #+END_SRC

***** 文件远程归档
	  既然tar程序可使用管道，就可以结合ssh程序实现远程文件归档传输，如
	  将远程主机上的Document文件夹打包压缩后发送到本地：
	  #+BEGIN_SRC shell-script
        # 本地文件夹
        mkdir remote-suff
        # 远程传输
        cd remote-stuff
        ssh remote-sys 'tar cf - Documents | gzip' | tar zxf -
	  #+END_SRC
**** zip
	 zip程序是一个同时打包和压缩工具。打包压缩后的文件后缀为.zip。

	 zip的主要使用场景是兼容Windows系统。 *Unix上首选的压缩工具是gzip，
	 其次是bzip2，最后才是zip。*

	 zip程序的用法为：

	 #+BEGIN_EXAMPLE
       zip options zipfile file...
	 #+END_EXAMPLE

	 如将playground文件夹打包压缩：

	 #+BEGIN_SRC shell-script
       zip -r playground.zip playground
	 #+END_SRC

	 注意点：
	 1. 打包压缩文件夹需使用-r(recursive)参数，否则只会打包压缩空的
        playground文件夹。
	 2. 执行程序过程中，如果仅是打包会显示"stored"文件，如果有压缩会显
        示"deflat"文件，显示信息行末的百分数表示压缩量。

	 解压zip文件使用unzip程序：

	 #+BEGIN_SRC shell-script
       cd foo
       unzip ../playground.zip
	 #+END_SRC

	 注意点：
	 1. 与tar命令相反，如果文件存在，unzip解压文件时会保留原有文件而不
        是替换原有文件。
	 2. 使用-l参数可查看打包文件中的文件详情，如需更详细信息，可添加-v
        参数。不跟指定文件名（需为打包时的文名绝对路径）文件包中的所有
        文件。

	 zip程序也可使用标准输入/出流，不过不使用"-"标记，而是"-@"：

	 #+BEGIN_SRC shell-script
       find playground/ -name 'file-A' | zip -@ file-A.zip
	 #+END_SRC

	 注意：这时生成文件和原文件的顺序相反。

	 zip可使用标准输出流，可用于接受其他程序的输出结果：

	 #+BEGIN_SRC shell-script
       ls etc/ | zip ls-etc.zip -
	 #+END_SRC

	 /这里为啥又使用“-”作为标准输入流，和上一个使用find的例子不一样？？
	 ？:question:/

	 而unzip程序只能使用标准输出流，不能使用标准输入流。这样以阻止结合
	 zip和unzip通过网络复制文件。unzip使用参数-p可将结果输出到标准输出
	 流：

	 #+BEGIN_SRC shell-script
       unzip -p ls-etc.zip | less
	 #+END_SRC

*** rsyn-文件同步
	系统备份的策略之一就是将一个或多个文件夹在本地（如移动存储设备）或
	远程同步。

	比如在本地开发网站，需随时同步到远程服务器。在Unix环境中，适用于此
	情景的首选程序是rsync（remote synchronous）。其原理为快速计算2个文
	件夹的差异，复制尽量少的内容实现同步。与其他复制程序相比既高效又经
	济。

	使用方法为：

	#+BEGIN_EXAMPLE
      rsync options source destination
	#+END_EXAMPLE

	source和destination可为下面3类文件：
	1. 本地文件/文件夹。
	2. 以"[use@]host:path"形式存在的远程文件/文件夹。
	3. 以"rsync://[user@]host[:port]/path"指定的远程rsync服务器。

	注意：不支持远程对远程的文件同步。
**** 本地同步
	 下面举例展示使用rsync程序同步本地文件。首先删除foo文件夹中的内容：

	 #+BEGIN_EXAMPLE
       rm -rf foo/*
       rsync -av playground foo
       dir-100/
       dir-100/file-A

       ...

       sent 7,494 bytes  received 2,323 bytes  19,634.00 bytes/sec
       total size is 0  speedup is 0.00
	 #+END_EXAMPLE

	 - -a参数表示归档，即保证历遍文件夹中的所有文件，且保持文件属性不变。
	 - -v参数为执行过程中显示详细信息。且在执行完毕后显示复制概况。

	 再执行上一个命令：

	 #+BEGIN_EXAMPLE
       sending incremental file list

       sent 3,283 bytes  received 112 bytes  6,790.00 bytes/sec
       total size is 0  speedup is 0.00
	 #+END_EXAMPLE

	 此时不会列出任何文件，因为rsync侦测出没有文件需要复制。

	 如果修改其中一个文件再执行上个命令：
	 #+BEGIN_EXAMPLE
       touch playground/file-A
       rsync -av playground foo
       sending incremental file list
       dir-001/file-A

       sent 3,336 bytes  received 135 bytes  6,942.00 bytes/sec
       total size is 0  speedup is 0.00
	 #+END_EXAMPLE
	 这里rsync只侦测出一个文件有改动，所以只同步了它。如果改变了目标文
	 件（即foo文件夹），同步时也会侦测出来。

	 下面举一个实际点的例子。假设有一个U盘挂载到了/media/BigDisk上，将
	 重要的系统文件同步到此文件夹中：
	 #+BEGIN_SRC shell-script
       mkdir /media/BigDisk/backup
       sudo rsync -av --delete /etc /home /media/BigDisk/backup
	 #+END_SRC
	 这里首先创建了一个新文件夹，然后同步。

	 --delete参数的含义为删除backup文件夹中存在，但在系统中不存在的文
     件。首次备份可不使用，不过对以后的每次备份都很有用。

	 如需经常使用此操作，可将其作为别名添加到.bashrc文件中：
	 #+BEGIN_SRC shell-script
       alias backup='sudo mkdir -p /media/BigDisk/backup && sudo rsync -av --delete /etc /home /media/BigDisk/backup'
	 #+END_SRC

	 mkdir程序使用-p参数时，既可以在没有父文件夹时创建，也可在文件夹已
	 经存在的情况下不报错。上例就是用的第二个特性。

**** 远程同步
	 rsync程序正真的优雅在于在网络间复制文件。毕竟其缩写为“REMOTE
	 synchronous”。有2种方法使用rsync程序：

	 1. 与另一台安装rsync和远程shell程序（如ssh）的计算机间复制文件。
        比如将本地文件备份到远程计算机remote-sys上的/backup文件夹中：
		#+BEGIN_SRC shell-script
          sudo rsync -av --delete --rsh=ssh /etc/ /home/ /usr/local/ remote-sys:/backup
		#+END_SRC
		这里使用参数--rsh=ssh的目的是使rsync使用ssh作为远程shell。这样
        就可以通过ssh加密通道传输文件。

	 2. 使用rsync服务器同步文件。rsync可配置为后台程序，监听同步请求。
        常用来镜像远程系统。比如同步Fedora系统仓库：
		#+BEGIN_SRC shell-script
          mkdir fedora-devel
          rsync -av --delete rsync://rsync.gtlib.gatech.edu/fedora-linux-core/development/i386/os fedora-devel
		#+END_SRC
		rsync://为协议名，rsync.gtlib.gatech.edu为主机名，为文件路径。

** 正则表达式
   在类Unix系统中，文本数据的角色相当重要。接下来的几章会学习文本处理
   工具。不过需先学习正则表达式作为基础铺垫。

   正则表达式可能是本书中最难理解的内容。不过其功能强大，越早掌握越好。
*** 何为表达式
	正则表达式是用符号表示文本模板的一种标记。许多命令行工具和编程语言
	都支持正则表达式。不过，不同工具，不同编程语言中的正则表达式各有不
	同。本章只介绍POSIX规范的正则，适用于绝大多数命令行工具。
*** grep程序
	grep为“global regular expression print”的缩写，可见与正则（以后都
	用“正则”说“正则表达式”）的关系；即搜索文件中与正则匹配的文本，然后
	输出该行。目前为止都是使用grep匹配特定文本：
	#+BEGIN_SRC shell-script
      ls /usr/bin/ | grep zip
	#+END_SRC

	grep的使用方法为：
	#+BEGIN_EXAMPLE
      grep [options] regex [file...]
	#+END_EXAMPLE

	以下为grep的一些常用参数：

    | -i | --ignore-case         | 不区分大小写                       |
    | -v | --invert-match        | 取反。打印不匹配的行               |
    | -c | --count               | 只显示匹配数量                     |
    | -l | --files-with-matches  | 显示包含匹配的文件名               |
    | -L | --files-without-match | 显示不包含匹配的文件名             |
    | -n | --line-number         | 显示匹配行在文件中的行数           |
    | -h | --no-filename         | 搜索多个文件时，不显示默认的文件名 |

	为展示grep的使用方法，下面创建一些文件来实验：
	#+BEGIN_EXAMPLE
      claudio@kali:$ ls /bin/ > dirlist-bin.txt
      claudio@kali:$ ls /usr/bin/ > dirlist-usr-bin.txt
      claudio@kali:$ ls /sbin/ > dirlist-sbin.txt
      claudio@kali:$ ls /usr/sbin/ > dirlist-usr-sbin.txt
      claudio@kali:$ ls dirlist*.txt
      dirlist-bin.txt  dirlist-sbin.txt  dirlist-usr-bin.txt  dirlist-usr-sbin.txt
	#+END_EXAMPLE

	下面对这些文件搜索：
	#+BEGIN_EXAMPLE
      claudio@kali:$ grep bzip dirlist*.txt
      dirlist-bin.txt:bzip2
      dirlist-bin.txt:bzip2recover
	#+END_EXAMPLE

	如果只需查看有匹配的文件名，可使用参数-l：
	#+BEGIN_EXAMPLE
      claudio@kali:$ grep -l bzip dirlist*.txt
      dirlist-bin.txt
	#+END_EXAMPLE

	相反，查看不包含匹配的文件名使用-L参数：
	#+BEGIN_EXAMPLE
      claudio@kali:$ grep -L bzip dirlist*.txt
      dirlist-sbin.txt
      dirlist-usr-bin.txt
      dirlist-usr-sbin.txt
	#+END_EXAMPLE
*** 元字符和普通字符
	grep程序实际上使用的匹配（如上面的"bzip"）都是正则。上例中的“bzip”
	表示文件中的含"bzip"这4个字符。

	如“bzip”中的字符称为普通字符，元字符则有：
	#+BEGIN_EXAMPLE
      ^ $ . [ ] { } - ? * + ( ) | \
	#+END_EXAMPLE

	其中转义符'\'的作用是将元字符转义为普通字符。

	*如果在shell中使用正则，元字符中的一些会膨胀，为避免这种情况使用时
    需配合单引号或双引号使用。*

*** 任意字符
	使用元字符'.'可匹配该位置上的任意字符。如：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -h '.zip' dirlist*.txt
      bunzip2
      bzip2
      bzip2recover
      gunzip
      gzip
      fcrackzip
      fcrackzipinfo
      funzip
      gpg-zip
      p7zip
      preunzip
      prezip
      prezip-bin
      unzip
      unzipsfx
	#+END_EXAMPLE

	注意点：
	1. 并没有匹配"zip"，因为使用了点元字符后，该位置上需一个字符。
	2. 也可匹配“.zip”，因为匹配任意字符也包括匹配点字符本身。

*** 锚字符
	插入符'^'和美元符'$'为锚字符，分别代表行首和行末。如匹配以"zip"开
	头的行：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -h '^zip' dirlist*.txt
      zip
      zipcloak
      zipdetails
      zipgrep
      zipinfo
      zipnote
      zipsplit
      zip2john
	#+END_EXAMPLE

	匹配以"zip"结尾的行：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -h 'zip$' dirlist*.txt
      gunzip
      gzip
      fcrackzip
      funzip
      gpg-zip
      p7zip
      preunzip
      prezip
      unzip
      zip
	#+END_EXAMPLE

	可见上2例都匹配了"zip"，如需准确匹配一个文本可同时使用这2个锚字符：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -h '^zip$' dirlist*.txt
      zip
	#+END_EXAMPLE

	正则'^$'表示首尾都无内容，即匹配空行。

*** 括号表达式（bracket expression）
	括号表达式可在该位置上匹配方括号中的任意一个字符，如匹配"bzip"或
	"gzip"：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -h '[bg]zip' dirlist*.txt
      bzip2
      bzip2recover
      gzip
	#+END_EXAMPLE

	括号表达式中的字符可为任意多个；且所有元字符都都失去特殊意义，成为
	普通字符，只有2个例外：
	1. 插入符'^'：表示取反。
	2. '-'：表示范围。

**** 取反
	 如果方括号中的第一个字符为'^'则表示该位置上不包含其中字符的任意一
	 个：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ grep -h '[^bg]zip' dirlist*.txt
       bunzip2
       gunzip
       fcrackzip
       fcrackzipinfo
       funzip
       gpg-zip
       p7zip
       preunzip
       prezip
       prezip-bin
       unzip
       unzipsfx
	 #+END_EXAMPLE

	 注意点：
	 - 没有匹配"zip"，因为即使排除字符，但也需该位置上有字符。
	 - '^'只有是第一个字符才有取反的作用，如果在其他位置就是普通字符。

**** 传统字符范围
	 查看所有以大写字符开头的行：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ grep -h '^[ABCDEFGHIJKLMNOPQRSTUVWXZY]' dirlist*.txt
       ATR_analysis
       BlindElephant.py
       CAT
       ...
	 #+END_EXAMPLE

	 但使用字符范围表达更简便：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ grep -h '^[A-Z]' dirlist*.txt
       ATR_analysis
       BlindElephant.py
       CAT
       ...
	 #+END_EXAMPLE

	 也可同时指定多个范围，如过滤所有以字母和数字开始的行：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ grep -h '^[A-Za-z0-9]' dirlist*.txt
       ...
	 #+END_EXAMPLE

	 可见在方括号中，'-'会被特殊对待；需匹配'-'本身的一般做法是将其放
	 在最前面：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ grep -h '^[-AZ]' dirlist*.txt
       ATR_analysis
	 #+END_EXAMPLE

**** POSIX字符类
	 上面的传统字符范围简单高效，但并不是始终奏效。使用grep程序目前为
	 止还没遇到问题，单使用其他程序时可能会碰到。

	 如路径膨胀时通配符（wildcard）的用法和基本和正则相同，但如下例：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*
       /usr/sbin/ModemManager  /usr/sbin/NetworkManager
	 #+END_EXAMPLE

	 可获取希望得到的结果，即显示所有以大写字母开头的行。但是：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/sbin/[A-Z]*
       /usr/sbin/base64conv             /usr/sbin/inetmask                 /usr/sbin/samba_spnupdate
       /usr/sbin/besside-ng             /usr/sbin/install-menu             /usr/sbin/samba_upgradedns
       ...
	 #+END_EXAMPLE

	 出现此情况的原因在于环境字符编码问题。最初使用的ASCII码中字母排序
	 为：
	 #+BEGIN_EXAMPLE
       ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
	 #+END_EXAMPLE

	 而后来为了多语言支持，ASCII码从7位升到了8位，即从127个字符增加到
	 了255个字符（即UTF-8）。使得字母排序变成了：
	 #+BEGIN_EXAMPLE
       aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
	 #+END_EXAMPLE

	 这就解释了为何第二例中的结果为何从字母'b'开始。因为"[A-Z]"实际上
	 是除字母'a'外的所有字母。

	 POSIX标准为了兼容，通过 /locale/ 控制使用ASCII还是UTF_8。查看方法
	 为：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo $LANG
       en_US.UTF-8
	 #+END_EXAMPLE

	 查看locale的方法为：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ locale
       LANG=en_US.UTF-8
       LANGUAGE=
       LC_CTYPE="en_US.UTF-8"
       ...
	 #+END_EXAMPLE

	 所以，可通过$LANG变量设置是使用ASCII还是UTF-8。如果$LANG值为POSIX
	 则使用ASCII。设置方法为：
	 - 只在当前命令行会话中有效：
	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ export LANG=POSIX
	   #+END_EXAMPLE
	   这样设置后，上面第一例就会输出希望的结果。
	 - 永久保存则是在.bashrc中添加
	   #+BEGIN_SRC shell-script
         export LANG=POSIX
	   #+END_SRC
	   /这样会改变整个系统的字符编码为ASCII，需谨慎使用。/

	 为解决直接上面问题，POSIX标准定义了相当于字符范围的“字符类”。如下：

     | 字符类     | 含义                                                                 | ASCII等价值   |
     |------------+----------------------------------------------------------------------+---------------|
     | [:alnum:]  | 字母数字字符                                                         | [A-Za-z0-9]   |
     | [:word:]   | 在[:alnum:]的基础上添加了字符下划线'_'                               |               |
     | [:alpha:]  | 字母                                                                 | [A-Za-z]      |
     | [:blank:]  | 空格和tab                                                            |               |
     | [:cntrl:]  | ASCII控制符，ASCII码0-31和127                                        |               |
     | [:digit:]  | 数字0-9                                                              |               |
     | [:graph:]  | 可见字符，ASCII值33-126                                              |               |
     | [:lower:]  | 小写字母                                                             |               |
     | [:punct:]  | 标点字符                                                             |               |
     | [:space:]  | 空白字符，包括空格、tab、carriage、newline、vertical tab 和form feed | [ \t\r\n\v\f] |
     | [:upper:]  | 大写字母                                                             |               |
     | [:xdigit:] | 表示16进制数的字符                                                   | [0-9A-Fa-f]   |

	 利用上面的字符类，可将一开始的例子改写为：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/sbin/[[:upper:]]*
       /usr/sbin/ModemManager  /usr/sbin/NetworkManager
	 #+END_EXAMPLE

	 /此处并不是正则，是膨胀，只是POSIX的字符类在正则和膨胀中都可以。/

*** POSIX规范中的基本正则表达式和扩展正则表达式
	[[http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX][阅读infoq上的文章总结：]]

	#+BEGIN_QUOTE
	常见的正则表达式都源于Perl，并衍生出了PCRE（Perl Compatible
	Regular Expression），使用\d、\w和\s等记法是其主要特点。其它还有一
	些流派，就比如本章讲解的POSIX。

	POSIX规范

	全称为Portable Operating System Interface for uniX，其实也是由一系
	列规范构成。它由定义了BRE（Basic Regular Expression，基本正则表达
	式）和ERE（Extended Regular Expression，扩展正则表达式）2大规范。

	在兼容POSIX的Unix系统上，grep和egrep之类的工具都遵循POSIX规范，一
	些数据库系统中的正则表达式也符合POSIX规范。

	BRE

	grep、vi、sed都属于BRE一派。语法比较怪异，元字符’(’、’)’、‘{’和‘}’
	必须转义后才有特殊含义。所以“(a)b”只能匹配字符串“(a)b”而不是"ab"；
	正则"a{1,2}"只能匹配字符串"a{1,2}"，只有“a\{1,2\}”才能匹配字符串a
	或aa。

	之所以这么麻烦，是因为这些工具诞生很早，当时正则表达式还在逐渐发展，
	这些字符还没特殊含义；为了向后兼容，只能使用转义。而且有些功能还不
	支持如量词'+'和'?'，反向引用'\1'，以及多选结构'...|...'。

	如今，GNU已近对BRE进行了扩展，也支持'+'、'?'和'|'，不过需写
	成'\+'、'\?'和'\|'。所有，GNU的grep等工具名义上属于BRE流，确切点说
	应该为GNU BRE。

	ERE

	常用工具egrep和awk则属于ERE流派。不兼容BRE语法，自成一体。元字符不
	需转义直接使用（使用反斜杠转以后反而会让元字符失去特殊含义）。所以
	正则'(ab|cd)'就可匹配字符串'ab'或'cd'，量词'+'、'?'和'{m, n}'可直
	接使用。ERE并没明确规定是否支持反向引用，单不少工具都支持'\1'和'\2'这
	样的反向引用。

	实际上GNU ERE只是个说法而已，它有的功能其实GNU BRE都有了，只是元字
	符不需转义。

	POSIX中的字符组

	POSIX中，根据语言环境(locale)的不同(ANSII或Unicode)变化字符组含义。

	locale是一组有关语言和文化的设定，如日期格式、货币币值和字符编码等。
	#+END_QUOTE

	在BRE中，除下面的字符外，都是普通字符：
	#+BEGIN_EXAMPLE
      ^ $ . [ ] *
	#+END_EXAMPLE

	ERE中添加了字符：
	#+BEGIN_EXAMPLE
      ( ) { } ? + |
	#+END_EXAMPLE

	在BRE中，字符'('、')'、'{'、'}'转义后被当做元字符；ERE中对任何元字
	符转义都会使其变为普通字符。

	如需使GNU grep程序支持ERE，可添加-E参数，也可使用程序egrep。

	#+BEGIN_QUOTE
	个人总结：
	POSIX的字符类是讨论的字符范围，为ERE和BRE是讨论的元字符区别。两者
	学分开思考，不然更懵。
	#+END_QUOTE
*** 多选
	/下面都为ERE。/

	括号表达式选择匹配单个字符，而多选可选择匹配多个字符。下面结合echo
	和grep展示用法：

	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ echo "AAA" | grep AAA
      AAA
      claudio@kali:~/foo$ echo "BBB" | grep AAA
      claudio@kali:~/foo$
	#+END_EXAMPLE

	上例将echo的标准输出通过管道传递给grep，如果匹配则显示，不匹配则不
	显示任何内容。

	下面使用多选：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ echo "AAA" | grep -E 'AAA|BBB'
      AAA
      claudio@kali:~/foo$ echo "BBB" | grep -E 'AAA|BBB'
      BBB
      claudio@kali:~/foo$ echo "CCC" | grep -E 'AAA|BBB'
      claudio@kali:~/foo$
	#+END_EXAMPLE

	上例中的“AAA|BBB”含义为匹配字符串"AAA"或字符串"BBB"。注意：
	1. 多选为ERE的特性，所以grep使用了-E参数（也可使用egrep程序）。
	2. 正则用引号包裹，避免竖线解释为管道。

	如需与其他正则结合使用，将多选用括号包裹：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -Eh '^(bz|gz|zip)' dirlist*.txt
	#+END_EXAMPLE
	匹配以bz、gz或zip开始的行。

	下例的含义为以bz开头或包含gz，或包含zip：
	#+BEGIN_EXAMPLE
      claudio@kali:~/foo$ grep -Eh '^bz|gz|zip' dirlist*.txt
	#+END_EXAMPLE

*** 个数修饰字符
**** ? - 匹配0次或1次
	 以验证电话号码的格式为例，假设电话号码的格式为：
	 #+BEGIN_EXAMPLE
       (nnn) nnn-nnnn
       nnn nnn-nnnn
	 #+END_EXAMPLE

	 则正则应为：
	 #+BEGIN_EXAMPLE
       ^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
	 #+END_EXAMPLE

	 由于这是ERE特性，所以括号需转义；使用问号表示有无括号都可。

	 如以下例子：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "(555) 123-4567" | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
       (555) 123-4567
       claudio@kali:~/foo$ echo "555 123-4567" | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
       555 123-4567
       claudio@kali:~/foo$ echo "AAA 123-4567" | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
       claudio@kali:~/foo$
	 #+END_EXAMPLE
**** * - 匹配任意次（包括0次）
	 "?"是匹配0次或1次，而"*"也可匹配0次，但也可以是任意多次。

	 假设一个英语句子是以大写字母开始，含任意多个大小写字母和空格，结尾为"."，则正则应为：
	 #+BEGIN_EXAMPLE
       [[:upper:]][[:upper:][:lower:] ]*\.
	 #+END_EXAMPLE

	 注意点：
	 1. 字符类需与括号表达式一起使用，表示字符范围，所以"[:upper:]"还
        需要中括号包裹。
	 2. "."为元字符，需转义。

	 例：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "This works." | grep -E '[[:upper:]][[:upper:][:lower:] ]*\.$'
       This works.
	 #+END_EXAMPLE

**** + - 匹配至少1次
	 需至少一个字符满足条件。

	 下面为匹配用单个空格分开的多组由1个或多个字母组成的行：
	 #+BEGIN_EXAMPLE
       ^([[:alpha:]]+ ?)+$
	 #+END_EXAMPLE

	 如下例：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "This that" | grep -E '^([[:alpha:]]+ ?)+$'
       This that
       claudio@kali:~/foo$ echo "a b c" | grep -E '^([[:alpha:]]+ ?)+$'
       a b c
       claudio@kali:~/foo$ echo "a b 9" | grep -E '^([[:alpha:]]+ ?)+$'
       claudio@kali:~/foo$ echo "abc  d" | grep -E '^([[:alpha:]]+ ?)+$'
       claudio@kali:~/foo$
	 #+END_EXAMPLE

**** {} - 指定匹配次数

     | 构成  | 含义    |
     |-------+---------|
     | {n}   | x==n    |
     | {n,m} | n<=x<=m |
     | {n,}  | x>=n    |
     | {,m}  | x<=m    |

	 可使用此特性将上面验证电话号码的正则改写为：
	 #+BEGIN_EXAMPLE
       ^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$
	 #+END_EXAMPLE

	 例：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "(555) 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
       (555) 123-4567
       claudio@kali:~/foo$ echo "555 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
       555 123-4567
       claudio@kali:~/foo$ echo "5555 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'
       claudio@kali:~/foo$
	 #+END_EXAMPLE

*** 实践
**** 使用grep验证电话簿
	 先使用下面的命令生成文件phonelist.txt，其中含格式不正确的电话随机
	 电话号码：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ for i in {1..10} ; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt;done
       claudio@kali:~/foo$ cat phonelist.txt
       (371) 361-658
       (691) 631-9427
       (162) 715-1189
       (230) 595-1260
       (211) 105-1102
       (292) 254-7236
       (763) 482-2078
       (154) 204-1602
       (201) 709-801
       (311) 130-1071
	 #+END_EXAMPLE

	 下面使用grep结合-v参数查看不满足条件的电话号码：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ grep -Ev '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$' phonelist.txt
       (371) 361-658
       (201) 709-801
	 #+END_EXAMPLE

**** 使用find查找“丑陋”的文件名
	 find结合-regex参数就可使用正则查找文件。不过需注意：对grep而言，
	 只要单行内包含正则匹配的内容就可成功匹配；而find则是需要整行与正
	 则匹配才能成功匹配。

	 假设"丑陋"的文件名为有不是下列正则中的字符：
	 #+BEGIN_EXAMPLE
       [-_./0-9a-zA-Z]
	 #+END_EXAMPLE

	 这查找命令为：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ find . -regex '.*[^-_./0-9a-zA-Z].*'
	 #+END_EXAMPLE

	 由于find使用正则时需匹配整行，所以前后都用了".*"来匹配任意字符。

**** 使用locate查找文件
	 使用locate查找文件时，如果使用参数--regexp可支持BRE，使用--regex
	 则支持ERE。

	 下例为使用ERE查找路径中含bin/bz、bin/gz或bin/zip：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ locate --regex 'bin/(bz|gz|zip)'
	 #+END_EXAMPLE

**** 在less和vim中查找文本
	 使用less阅读文件时，按下"/"就可输入正则进行查找。

	 但在vim中，只支持BRE，所以上面匹配电话号码的正则应为：
	 #+BEGIN_EXAMPLE
       ([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}
	 #+END_EXAMPLE
**** 使用zgrep在压缩文件中查找
	 zgrep程序可实现对压缩文件进行查找。如查找系统文档中有包含"regex
	 expression"或"regular expression"文本的手册文件：
	 #+BEGIN_EXAMPLE
       claudio@kali:/usr/share/man/man1$ zgrep -El '(regex|regular) expression' *.gz
       ag.1.gz
       apropos.1.gz
       ...
	 #+END_EXAMPLE

	 正则表达式还有一个称为"反向引用(back reference)"的特性，以后讨论。

** 文本处理
   所有类Unix系统都强烈依赖文本文件存储数据。有许多文本处理工具也理所
   当然。本章主要介绍文本拆分和合并命令，下一章主要介绍为方便阅读的文
   本格式化和打印命令。

   - *cat* ：合并文件，输出到标准输出流。
   - *sort* ：排序文本文件。
   - *uniq* ：显示（不）重复的行。
   - *cut* ：移除每行中指定的区域。
   - *past* ：合并文本中的各行。
   - *join* ：合并文本中“域（field）”相同的行。
   - *comm* ：逐行比较已排序文本中的每行。
   - *diff* ：逐行比较文本。
   - *patch* ：使用diff命令的结果改变原文件。
   - *tr* ：转换或删除字符。
   - *sed* ：过滤和转换文本的流编辑器。
   - *aspell* ：交互式拼写检查。

*** 文本用途分类
	文本文件的主要用途分类：
	1. 文档
	2. 网页
	3. Email
	4. 打印输出
	5. 程序源代码
*** 复习以前学过的文本处理命令
**** cat
	 cat程序有许多参数，其中一个为-A。此参数可用来查看不可见的控制字符，
	 最常用的是：

	 1. 查看空格是tab还是空格键。
	 2. 查看换行符是Unix的换行符，还是MS-DOS的换行符。

	 下面使用cat程序在标准输输入流中输入tab，并且在行末输入空白字符，
	 以<C-d>（end-of-file）结束输入：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cat > foo.txt
               The quick brown fox jump over the lazy dog.
	 #+END_EXAMPLE

	 再用带参数-A的cat程序查看foo.txt文件：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo cat -A foo.txt
       ^IThe quick brown fox jump over the lazy dog.      $
	 #+END_EXAMPLE

	 可见tab显示为"^I"；正真的行末为"$"，表明行末有空格。

	 #+BEGIN_QUOTE
	 MS-DOS文本和Unix文本

	 Unix文本用linefeed（ASCII 10）字符作为换行符，DOS文本用carriage
	 return字符（ASCII 13）作为换行符。使用cat带参数-A就可看出是哪种系
	 统文本。

	 使用dos2unix和unix2dos两个程序就可实现转换。
	 #+END_QUOTE

	 cat程序的另外2个常见参数：
	 - -s：将多个空行显示为1个空行。
	 - -n：显示行数。

**** sort
	 sort程序可排标准输入流，一个或多个文本，将排序结果输出到标准输出
	 流。

	 下面使用与上一节cat相同的方法将标准输入流中的文本排序后输出到文本
	 内：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort > foo.txt
       c
       b
       a
       claudio@kali:~/foo$ cat foo.txt
       a
       b
       c
	 #+END_EXAMPLE

	 sort可接受多个文件，可将多个文件排序后合并为一个文件。如将3个文
	 件排序后合并为1个文件：
	 #+BEGIN_EXAMPLE
       sort file1.txt file2.txt file3.txt > final_sorted.txt
	 #+END_EXAMPLE

	 下面为sort的一些常用参数：

     | 参数 | 全写                    | 含义                                       |
     |------+-------------------------+--------------------------------------------|
     | -b   | --ignore-leading-blanks | 默认情况下，从第一个字符开始排序整行       |
     | -f   | --ignore-case           | 忽略大小写                                 |
     | -n   | --numeric-sort          | 默认使用字母排序                           |
     | -r   | --reverse               | 默认排序为从小到大                         |
     | -k   | --key=filed1[,filed2]   | 基于field1到filed2间的文本排序             |
     | -m   | --merge                 | 假设多个文件都已排序好，合并时不再单个排序 |
     | -o   | --output=file           | 将排序结果输出到file，而非标准输出流       |
     | -t   | --field-separate=char   | 默认各列间的间隔为一个（或多个）空格或tab  |

	 上面的大多数参数较简单，但有些不然。首先，比如使用-n参数进行数字
	 排序。使用du程序可查看文件大小：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ du -s /usr/share/* | head
       48                  /usr/share/aclocal
       8                   /usr/share/adduser
       144                 /usr/share/adium
       116                 /usr/share/aglfn
       ...
	 #+END_EXAMPLE

	 下面使用sort的-n参数对du程序的结果进行排序：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ du -s /usr/share/* | sort -nr | head
       768200              /usr/share/doc
       693020              /usr/share/texlive
       477856              /usr/share/locale
       ...
	 #+END_EXAMPLE

	 但是如果程序结果中表示大小的fied不在第一列，如ls程序的结果。需配
	 合-k参数一起使用（此处暂不考虑ls程序可实现按文件大小排序）：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls -l /usr/bin/ | head | sort -nr -k 5
       -rwxr-xr-x 1 root root       52008 Dec  9 22:08 [
       -rwxr-xr-x 1 root root       10392 Apr  7  2016 411toppm
       -rwxr-xr-x 1 root root        2376 Aug 10  2013 0trace.sh
       -rwxr-xr-x 1 root root          96 Jan  3 12:40 2to3-3.5
       -rwxr-xr-x 1 root root          96 Dec 19 04:19 2to3-2.7
       -rwxr-xr-x 1 root root          40 Nov 19 15:52 7zr
       -rwxr-xr-x 1 root root          40 Nov 19 15:52 7za
       -rwxr-xr-x 1 root root          39 Nov 19 15:52 7z
       lrwxrwxrwx 1 root root           8 Dec 20 18:15 2to3 -> 2to3-2.7
       total 515520
	 #+END_EXAMPLE

	 sort程序一般用于处理“表格式数据（tabular data）”，如上面的ls输出。
	 如果将上面的表格类比于数据库，则每行为一条记录（record），一行内
	 部由包含多个域（field），如文件属性、链接数量，文件名等。sort程序
	 可处理单个域。即以数据库的形式来讲，可使用--key参数来排序单个或多
	 个域(field)。如上例使用了-n和-r参数来将第5个域按数字逆序排序。

	 参数-k有许多特点，但首先需了解sort如何定义域(field)，即key。如：
	 #+BEGIN_EXAMPLE
       William Shotts
	 #+END_EXAMPLE

	 sort默认有2个域，第一个含字符串：
	 #+BEGIN_EXAMPLE
       "William"
	 #+END_EXAMPLE

	 第2个含字符串：
	 #+BEGIN_EXAMPLE
       " Shotts"
	 #+END_EXAMPLE

	 即域之间用空格或tab隔开，且属于后面一个，并在排序时考虑。

	 以下面包含2006-2008年3个流行的Linux发行版发行时间列表为例：
	 #+BEGIN_EXAMPLE
       SUSE    10.2    12/07/2006
       Fedora  10      11/25/2008
       SUSE    11.0    06/19/2008
       Ubuntu  8.04    04/24/2008
       Fedora  8       11/08/2007
       SUSE    10.3    10/04/2007
       Ubuntu  6.10    10/26/2006
       Fedora  7       05/31/2007
       Ubuntu  7.10    10/18/2007
       Ubuntu  7.04    04/19/2007
       SUSE    10.1    05/11/2006
       Fedora  6       10/24/2006
       Fedora  9       05/13/2008
       Ubuntu  6.06    06/01/2006
       Ubuntu  8.10    10/30/2008
       Fedora  5       03/20/2006
	 #+END_EXAMPLE

	 存入文件distros.txt中。首先按默认的字母顺序排序：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort distros.txt
       Fedora              10   11/25/2008
       Fedora              5    03/20/2006
       Fedora              6    10/24/2006
       Fedora              7    05/31/2007
       Fedora              8    11/08/2007
       Fedora              9    05/13/2008
       SUSE                10.1 05/11/2006
       SUSE                10.2 12/07/2006
       SUSE                10.3 10/04/2007
       SUSE                11.0 06/19/2008
       Ubuntu              6.06 06/01/2006
       Ubuntu              6.10 10/26/2006
       Ubuntu              7.04 04/19/2007
       Ubuntu              7.10 10/18/2007
       Ubuntu              8.04 04/24/2008
       Ubuntu              8.10 10/30/2008
	 #+END_EXAMPLE

	 在第二列中，“10”排在了最前，原因为按字母顺序，"1"比"0"以外的数字
	 都小。为解决这一问题，可在第一个域上使用字母排序，第二个域上使用
	 数字排序。

	 sort程序的-k参数可有多个，且后面跟的域值可范围。如果不指定范围，
	 默认从起始点到行末：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort --key=1,1 --key=2n distros.txt
       Fedora              5    03/20/2006
       Fedora              6    10/24/2006
       Fedora              7    05/31/2007
       Fedora              8    11/08/2007
       Fedora              9    05/13/2008
       Fedora              10   11/25/2008
       SUSE                10.1 05/11/2006
       SUSE                10.2 12/07/2006
       SUSE                10.3 10/04/2007
       SUSE                11.0 06/19/2008
       Ubuntu              6.06 06/01/2006
       Ubuntu              6.10 10/26/2006
       Ubuntu              7.04 04/19/2007
       Ubuntu              7.10 10/18/2007
       Ubuntu              8.04 04/24/2008
       Ubuntu              8.10 10/30/2008
	 #+END_EXAMPLE

	 上面的参数可写成"-k 1,1 -k 2n"，域值范围后可跟改变排序的其他参数
	 的缩写：
	 1. b 忽略前面的空白字符
	 2. n 按数字排序
	 3. r 逆序排序

	 还可在单个域中按字符位置排序，如对第3个域排序：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt
       Fedora              10   11/25/2008
       Ubuntu              8.10 10/30/2008
       SUSE                11.0 06/19/2008
       Fedora              9    05/13/2008
       Ubuntu              8.04 04/24/2008
       Fedora              8    11/08/2007
       Ubuntu              7.10 10/18/2007
       SUSE                10.3 10/04/2007
       Fedora              7    05/31/2007
       Ubuntu              7.04 04/19/2007
       SUSE                10.2 12/07/2006
       Ubuntu              6.10 10/26/2006
       Fedora              6    10/24/2006
       Ubuntu              6.06 06/01/2006
       SUSE                10.1 05/11/2006
       Fedora              5    03/20/2006
	 #+END_EXAMPLE

	 "3.7"表示第3个域中的第7个字符，由于忽略前置空白字符才能计算出年的
	 起始位置是7，所以使用了b参数。

	 一些文件并不以空白字符分割域，可用-t参数指定分割符号，如：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort -t ':' -k 3 /etc/passwd | head
       root:x:0:0:root:/root:/bin/bash
       claudio:x:1000:1000:,,,:/home/me:/bin/bash
       systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
       uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
       systemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/false
       systemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/false
       systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false
       _apt:x:104:65534::/nonexistent:/bin/false
       mysql:x:105:109:MySQL Server,,,:/nonexistent:/bin/false
       epmd:x:106:110::/var/run/epmd:/bin/false
	 #+END_EXAMPLE

**** uniq
	 相比sort，uniq显得轻量一些，仅是删除重复行。一般与sort程序配合使
	 用。

	 GNU版本的sort程序有-u参数，可实现对排序后的重复行删除。

	 下面创建用于测试foo.txt文件：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cat > foo.txt
       a
       b
       c
       a
       b
       c
	 #+END_EXAMPLE

	 如果现在使用uniq程序删除重复的行：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ uniq foo.txt
       a
       b
       c
       a
       b
       c
	 #+END_EXAMPLE

	 不会有任何效果。因为，仅删除相邻的重复行：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort foo.txt | uniq
       a
       b
       c
	 #+END_EXAMPLE

	 下面为uniq的一些常用参数：

     | 参数 | 描述                                                                   |
     |------+------------------------------------------------------------------------|
     | -c   | 列出重复行，并在前面标明重复次数                                       |
     | -d   | 仅显示重复的行                                                         |
     | -f n | 忽略前面n个域。同sort一样，域间也是用空格或tab分开，不过不可重置分隔符 |
     | -i   | 忽略大小写                                                             |
     | -s n | 忽略每行前n个字符                                                      |
     | -u   | 仅显示不重复的行                                                               |

*** 拆分和合并文本
	下面介绍的3个命令都是用来分离合并文本列的。

**** cut
	 用于提取（表格式）文本中的列。

     | 参数            | 描述                                                                      |
     |-----------------+---------------------------------------------------------------------------|
     | -c /char_list/  | /char-list/ 为单个或多个由数字组成，逗号隔开的范围                        |
     | -f /field_list/ | /field_list/ 为单个或多个由数字组成的域，逗号隔开。 *域间默认间隔符为tab* |
     | -d /delim_char/ | 如果存在-f参数，则使用 /delim_char/ 作为间隔符                            |
     | --complement    | 提取除-c或/和-f参数指定的文本行                                           |

	 使用cat配合-A参数查看distros.txt可见，该文本“干净”（只有tab作为间
	 隔符），可直接使用-f参数提取：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cat -A distros.txt
       SUSE^I10.2^I12/07/2006$
       Fedora^I10^I11/25/2008$
       SUSE^I11.0^I06/19/2008$
       ...
	 #+END_EXAMPLE

	 使用-f参数提取时间所在的域：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cut -f 3 distros.txt
       12/07/2006
       11/25/2008
       06/19/2008
       ...
	 #+END_EXAMPLE

	 由于时间所在的域提取出来后，每行的长度都相等，所以可使用-c参数提
	 取指定范围内的字符：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cut -f 3 distros.txt | cut -c 7-10
       2006
       2008
       2008
       ...
	 #+END_EXAMPLE

	 #+BEGIN_QUOTE
	 如需将tab转换为空格，可使用expand命令。如：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ expand distros.txt | cut -c 23-
       2006
       2008
       2008
       ...
	 #+END_EXAMPLE

	 与之对应的unexpand命令可将空格转换为tab。

	 #+END_QUOTE

	 也可使用-d参数指定域间间隔符：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cut -d ':' -f 1 /etc/passwd | head
       root
       daemon
       bin
       ...
	 #+END_EXAMPLE

**** paste
	 paste程序与cut程序刚好相反，将各个文件中的列合并到一起，输出到标
	 准输出流。与cut相同，可接受多个文件或标准输入流。

	 下面利用distros.txt文件演示其功能。首先还是将该文件按时间顺序排序：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt > distros-by-date.txt
	 #+END_EXAMPLE

	 再将排序好的文件使用cut程序将第一和二列切割到新的文件中：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cut -f 1,2 distros-by-date.txt > distros-versions.txt
       claudio@kali:~/foo$ cat -A distros-versions.txt
       Fedora^I10$
       Ubuntu^I8.10$
       SUSE^I11.0$
       Fedora^I9$
	 #+END_EXAMPLE

	 再将第三列切割到另外一个文件：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ paste distros-dates.txt distros-versions.txt
       11/25/2008          Fedora                  10
       10/30/2008          Ubuntu                  8.10
       06/19/2008          SUSE                    11.0
       05/13/2008          Fedora                  9
       ...
	 #+END_EXAMPLE

**** join
	 join也是合并文件，但与paste不同的是使用同"关系型数据库(relational
	 database)"相同的原理合并，即将有相同field值的行合并。

	 以关系型数据库为例，如下面的2条记录：
	 #+BEGIN_EXAMPLE
       CUSTNUM FNAME   LNAME
       ======= =====   =====
       4681934 John    Smith
	 #+END_EXAMPLE

	 和

	 #+BEGIN_EXAMPLE
       ORDERNUM    CUSTNUM QUAN    ITEM
       ========    ======= ====    ====
       1212134     4681934 1       Blue Widget
	 #+END_EXAMPLE

	 都有key值CUSTNUM，合并后得到新记录：

	 #+BEGIN_EXAMPLE
       ORDERNUM    CUSTNUM QUAN    ITEM
       ========    ======= ====    ====
       1212134     4681934 1       Blue Widget
	 #+END_EXAMPLE

	 下面用distros-by-date.txt文件作为演示。首先新建2个文件，分别含名
	 称和版本号，都用时间列作为key值。

	 先生成名称文件：
	 #+BEGIN_EXAMPLE
       cclaudio@kali:~/foo$ cut -f 1,1 distros-by-date.txt > distros-names.txt
       claudio@kali:~/foo$ paste distros-dates.txt distros-names.txt > distros-key-names.txt
       claudio@kali:~/foo$ head distros-key-names.txt
       11/25/2008          Fedora
       10/30/2008          Ubuntu
       06/19/2008          SUSE
       ...
	 #+END_EXAMPLE

	 再生成版本文件：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cut -f 2,2 distros-by-date.txt > distros-vernums.txt
       claudio@kali:~/foo$ paste distros-dates.txt distros-vernums.txt > distros-key-vernums.txt
       claudio@kali:~/foo$ head distros-key-vernums.txt
       11/25/2008          10
       10/30/2008          8.10
       06/19/2008          11.0
       ...
	 #+END_EXAMPLE

	 由于这2个文件都有相同的时间域，即可使用join合并：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ join distros-key-names.txt distros-key-vernums.txt  | cat -A
       11/25/2008 Fedora 10$
       10/30/2008 Ubuntu 8.10$
       06/19/2008 SUSE 11.0$
       ...
	 #+END_EXAMPLE

	 注意，最后生成的文件去除了原来的tab，而使用空格来作为分隔符。参看
	 join的man手册详细了解。

*** 文本比较
	文件版本比较对系统管理员和软件开发者尤其重要。前者可将当前配置文件
	与以前的配置文件比较，以诊断系统；后者可随时查看程序更改情况。
**** comm
	 comm程序可比较2个文件，显示相同和不同之处。为演示方便，先使用cat
	 创建2个文件：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cat > file1.txt
       a
       b
       c
       d
       claudio@kali:~/foo$ cat > file2.txt
       b
       c
       d
       e
	 #+END_EXAMPLE

	 再使用comm对比：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ comm file1.txt file2.txt
       a
                       b
                       c
                       d
               e
	 #+END_EXAMPLE

	 可见，第一列为只有第一个文件才有的文本，第二列为只有第二个文件才
	 有的文本，第三列为两个文件都有的文本。

	 comm可使用参数-n（n为1或2或3），用来不显示上面对应的列数。如只显
	 示两个文件都有的文本：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ comm -12 file1.txt file2.txt
       b
       c
       d
	 #+END_EXAMPLE

**** diff
	 与comm相似，diff可用于检测文件的不同。却是个更复杂的工具，可支持
	 多种输出方式，并能单词处理大量文件。diff通常被软件开发者用来检查
	 程序不同版本之间的差异，即具有文件夹递归检查的功能。

	 diff一个常见的用法就是生成"diff文件（或patches）"，再使用patch程
	 序实现文件不同版本的切换。

	 如使用diff程序检查上面的2个文件：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ diff file1.txt file2.txt
       1d0
       < a
       4a4
       > e
	 #+END_EXAMPLE

	 可见，在默认的输出样式中，显示为将第一个文件转换为第二个文件的更
	 改命令（change command）。下面为diff的更改命令解释：

     | 更改  | 含义                                                               |
     |-------+--------------------------------------------------------------------|
     | r1ar2 | 将第二个文件中位置r2的文本行添加到第一个文件的r1位置               |
     | r1cr2 | 将第一个文件r1位置的文本行更改为第二个文件r2文职的文本行           |
     | r1dr2 | 删除第一个文件中r1位置的文本行，该文本行出现在第二个文本中的r2位置 |

	 这种默认的输出样式并不常用。下面介绍2种常用的输出样式。

	 第一个为“上下文格式（context format）”，使用参数-c：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ diff -c file1.txt file2.txt
       *** file1.txt   2017-02-01 00:49:32.523987870 +0800
       --- file2.txt   2017-02-01 00:49:40.451987636 +0800
       ***************
       *** 1,4 ****
       - a
         b
         c
         d
       --- 1,4 ----
         b
         c
         d
       + e
	 #+END_EXAMPLE

	 显示内容的前2行为，用不同符号标记的2个文件名称，及其时间戳。此处
	 标记的符号用在后面标记不同文件。

	 后面2块文本中符号的含义为：

     | 符号 | 含义                                         |
     |------+----------------------------------------------|
     | 空白 | 2个文本都相同                                |
     | -    | 删除。在第一个文件中有，而第二个文件中没有   |
     | +    | 添加。在第一个文件中没有，而在第二个文件中有 |
     | \!   | 更改。在2个文件的对应位置都会显示            |

	 第二种为“统一格式（unified form）”，使用参数-u：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ diff -u file1.txt file2.txt
       --- file1.txt   2017-02-01 00:49:32.523987870 +0800
       +++ file2.txt   2017-02-02 19:53:42.991966238 +0800
       @@ -1,4 +1,4 @@
       -a
        b
        c
        d
       +e
	 #+END_EXAMPLE

	 与第一种形式相同，都有2个文件的名称和时间戳。不过更简洁。“@@ -1,4
	 +1,4 @@”表示在2个文件中有区别的文本的行数范围。

	 正文中符号的含义为：

     | 符号 | 含义                               |
     |------+------------------------------------|
     | 空白 | 两个文件都有此行                   |
     | -    | 在第一个文件中有，第二个文件中没有 |
     | +    | 在第二个文件有，第一个文件中没有   |

**** patch
	 使用patch程序，可利用diff的对比结果，更新文件。其优势为：

	 1. 相比于整个文件，diff文件更小，传输更方便。
	 2. diff文件可清晰显示文件间的差异，阅读方便。

	 官方建议，生成diff文件的格式为：

	 #+BEGIN_EXAMPLE
       diff -Naur old_file new_file > diff_file
	 #+END_EXAMPLE

	 利用diff文件更新文件版本的格式为：

	 #+BEGIN_EXAMPLE
       patch < diff_file
	 #+END_EXAMPLE

	 此处并不需要指定目标文件，因为diff_file中已经有目标文件的信息。下
	 面以将file1.txt文件更改为file2.txt文件为例：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ diff -Nuar file1.txt file2.txt > patchfile.txt
       claudio@kali:~/foo$ patch < patchfile.txt
       patching file file1.txt
       claudio@kali:~/foo$ cat file1.txt
       b
       c
       d
       e
	 #+END_EXAMPLE

*** 即时编辑
	通常使用编辑器编辑文本都是交互式，而及时编辑则是指使用单个命令同时
	编辑多个文件。

**** tr
	 tr程序用于“直译（transliterate）”字符，相当于基于单个字符的查找替
	 换，即转换字符。如将小写字母转换为大写字母：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "lowercase letters" | tr a-z A-Z
       LOWERCASE LETTERS
	 #+END_EXAMPLE

	 tr接受标准输入，结果输出到标准输出。接受2组字符作为参数，参数可为
	 下面3种形式：

	 1. 枚举字符列表。如“ABCDEFGHIJKLMNOPQRSTUVWXYZ”。
	 2. 字符范围。如“A-Z”。与正则一样，依赖于本地环境，谨慎使用。
	 3. POSIX字符类。如“[:upper:]”

	 大多数情况下2组字符长度应该相等，单第一组也可比第二组长，如：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "lowercase letter" | tr [:lower:] A
       AAAAAAAAA AAAAAA
	 #+END_EXAMPLE

	 还可使用参数-d删除字符，如删除MS-DOS文本文件中的换行符：

	 #+BEGIN_EXAMPLE
       tr -d '\r' < dos_file > unix_file
	 #+END_EXAMPLE

	 可使用-s参数删除重复的字符，如：
	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "aaabbbccc" | tr -s ab
       abccc
	 #+END_EXAMPLE

**** sed

	 sed为“stream editor（流编辑器）”的缩写。即可编辑标准输入流，也可
	 编辑单个/多个文件。

	 可利用单个sed命令，也可使用含多个命令的脚本文件编辑。

	 下面为最简单的形式：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "front" | sed 's/front/back/'
       back
	 #+END_EXAMPLE

	 此处使用了sed的s命令（和vi相同）。所有命令都是单个字母，查找和替
	 换内容间的间隔符任意，不非一定为斜线，如：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "font" | sed 's_front_back_'
       font
	 #+END_EXAMPLE

	 大多数sed命令前都可跟地址，以指定操作的行，如果没有地址则表示操作
	 所有行。如上例只有一行的文本：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "front" | sed '1s/front/back/'
       back
       claudio@kali:~/foo$ echo "front" | sed '2s/front/back/'
       front
	 #+END_EXAMPLE

	 sed地址表示方法：

     | 地址        | 含义                            |
     |-------------+---------------------------------|
     | /n/         | 正整数。指定行                  |
     | \$          | 最后一行                        |
     | /regexp/    | POSIX的BRE正则表达式            |
     | addr1,addr2 | 地址范围。可为上面3种的任何一种 |
     | first~step  | 从first行开始，跳过step行       |
     | addr1,+n    | addr1表示的行，以及后面的n行    |
     | addr!       | 操作除addr行外的所有行          |

	 /上表中的addr为前3种中的任意一种。/

	 下面以distros.txt文件展示不同地址的用法：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sed -n '1,5p' distros.txt
       SUSE    10.2    12/07/2006
       Fedora  10      11/25/2008
       SUSE    11.0    06/19/2008
       Ubuntu  8.04    04/24/2008
       Fedora  8       11/08/2007
	 #+END_EXAMPLE

	 p命令为打印匹配行，-n参数则是取消默认显示所有文本行。

	 使用正则匹配行：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sed -n '/SUSE/p' distros.txt
       SUSE    10.2    12/07/2006
       SUSE    11.0    06/19/2008
       SUSE    10.3    10/04/2007
       SUSE    10.1    05/11/2006
	 #+END_EXAMPLE

	 显示不匹配正则的行：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sed -n '/SUSE/!p' distros.txt
       Fedora  10      11/25/2008
       Ubuntu  8.04    04/24/2008
       Fedora  8       11/08/2007
       ...
	 #+END_EXAMPLE

	 下面为sed的一些常用命令(参考自[[http://www.gnu.org/software/sed/manual/sed.html][GNU官网文档的sed页面]])：

	 - q [exit-code] 退出sed，不再进行任何处理和输出：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ seq 3 | sed 2q
         1
         2
	   #+END_EXAMPLE

	   只接受单个地址。

	 - d 删除匹配行（跳过改行）：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ seq 3 | sed 2d
         1
         3
	   #+END_EXAMPLE

	 - p 打印匹配行。通常与-n参数一起使用：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ seq 3 | sed -n 2p
         2
	   #+END_EXAMPLE

	 - n。？？？

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ seq 6 | sed 'n;n;s/./x/'
         1
         2
         x
         4
         5
         x
	   #+END_EXAMPLE

	 - {commands}复合命令。对匹配结果进行多个操作。

	   替换第二行后并打印：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ seq 3 | sed -n '2{s/2/X/ ; p}'
         X
	   #+END_EXAMPLE

	 - s/regexp/replacement/ 查找替换。

	   替换文本中，可使用&字符表示regexp匹配的文本。还可使用\1到\9作为
       正则的反向引用。

	   *使用-E参数可使用ERE正则，读写更方便。*

	   比如转换distros.txt文件中的时间格式。使用-E参数的写法为：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ sed -E 's/([0-9]{2})\/([0-9]{2})\/([0-9]{4})/\3-\1-\2/' distros.txt
         SUSE                10.2   2006-12-07
         Fedora              10     2008-11-25
         SUSE                11.0   2008-06-19
         ...
	   #+END_EXAMPLE

	   不使用用-E参数则应写为：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)/\3-\1-\2/' distros.txt
         SUSE                10.2                                                             2006-12-07
         Fedora              10                                                               2008-11-25
         SUSE                11.0                                                             2008-06-19
         ...
	   #+END_EXAMPLE

	   此处使用了正则的反向引用功能。BRE支持，单ERE可能不支持（此处可
       用）。

	   s命令还可以使用flag，如g（global），默认只替换第一个匹配：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ echo "aaabbbccc" | sed 's/b/B/'
         aaaBbbccc
	   #+END_EXAMPLE

	   使用g后可全局替换：

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ echo "aaabbbccc" | sed 's/b/B/g'
         aaaBBBccc
	   #+END_EXAMPLE

	   使用i可实现不区分大小写。

	   #+BEGIN_EXAMPLE
         claudio@kali:~/foo$ echo "aaabbBccc" | sed 's/b/2/gi'
         aaa222ccc
	   #+END_EXAMPLE

	 - y/set1/set2 直译。

	   将字符组set1转换为set2。与tr程序不同，需set1和set2需相等。

	 上面都是在单个命令中使用sed，也可结合-f参数使用sed脚本执行多个命
	 令。如使用下面的sed脚本distros.sed：

	 #+BEGIN_SRC text
       # sed script to produce Linux distributions report

       1i\
       \
       Linux Distributions Report\

       s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
       y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
	 #+END_SRC

	 使用-f参数执行的结果为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sed -f distros.sed distros.txt

       Linux Distributions Report

       SUSE    10.2    2006-12-07
       FEDORA  10      2008-11-25
       SUSE    11.0    2008-06-19
       ...
	 #+END_EXAMPLE

	 sed脚本中的3到6行的含义为使用sed的i命令插入文本。i命令有2种用法：

	 1. i text

		在指定行前插入文本：
		#+BEGIN_EXAMPLE
          claudio@kali:~/foo$ seq 3 | sed '2i hello'
          1
          hello
          2
          3
		#+END_EXAMPLE

	 2. i\
		text

		#+BEGIN_EXAMPLE
          claudio@kali:~/foo$ seq 3 | sed '2i\
          > hello'
          1
          hello
          2
          3
		#+END_EXAMPLE

		如果插入行需空白行，可在行末添加"\"表示行延续。此方法在shell脚
        本中同样适用，上列可改写为：

		#+BEGIN_EXAMPLE
          claudio@kali:~/foo$ seq 3 | sed '2i\
          > \
          > hello\
          > \
          > '
          1

          hello

          2
          3
		#+END_EXAMPLE

		*"\"后不能有空格*

	 脚本中最后一行使用了sed的y命令。此命令不支持字符范围（如[a-z]），
	 也不支持POSIX的字符类，所以使用了枚举字符。

**** aspell

	 aspell程序可用于交互式检查文本文件，如普通文本、HTML、源代码、邮
	 件等。基本使用方法为：

	 #+BEGIN_EXAMPLE
       aspell check textfile
	 #+END_EXAMPLE

	 如下例故意创建一个有拼写错误的文本，再使用apsell程序检查：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ cat > foo.txt
       The quick brown fox jimped over the laxy dog.
       claudio@kali:~/foo$ aspell check foo.txt
       claudio@kali:~/foo$
	 #+END_EXAMPLE

	 根据交互式菜单修改即可。默认会生成原文件后跟".bak"后缀的备份文件，
	 如需取消默认备份，可使用参数--dont-backup。

	 使用下面的sed命令，可将文件改回：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sed -i 's/lazy/laxy/; s/jumped/jimped/' foo.txt
       claudio@kali:~/foo$ cat -A foo.txt
       The quick brown fox jimped over the laxy dog.$
	 #+END_EXAMPLE

	 此处使用了sed的-i（in-place）参数，不输出结果，而是直接修改文件。
	 还可看出同时使用了多个命令。

** 格式化输出

   本章继续介绍文本处理相关的工具。与上章不同，这些工具的作用主要是格
   式化文本输出，而不是文本本身。这些工具的主要作用时为最终打印准备
   （下章内容）。

   - *nl* ： 标记行号。
   - *fold* ： 将每行折叠为指定宽度。
   - *fmt* ： 简单的文本格式工具。
   - *pr* ： 为打印格式化文本。
   - *printf* ： 格式化并输出文本。
   - *groff* ： 文件格式化系统 。

*** 简单的格式化工具

	这些工具不是很复杂，但结合管道使用可实现复制功能。

**** nl（Number Lines） - 标记行号

	 功能简单，但使用复杂。最简单的用法是列出行号，同“cat -n”的功能相
	 同：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ nl distros.txt
            1  SUSE    10.2    12/07/2006
            2  Fedora  10      11/25/2008
            3  SUSE    11.0    06/19/2008
            ...
	 #+END_EXAMPLE

	 同cat一样，nl也可接受多个文件或标准输入流。但nl有许多参数，可生成
	 复制的行号标记。

	 如果为多个文件，nl将它们作为一个文件看待。

	 标记行号时，nl支持“逻辑页（logical pages）”，可重置行号。逻辑页分
	 为header、body和footer三部分。每个部分都可重置行号，且使用不同的
	 标记样式。下面的标记作为不同部分的标识：

     | 标记   | 含义   |
     |--------+--------|
     | \:\:\: | header |
     | \:\:   | body   |
     | \:     | footer |

	 每个标记需单独成行，nl处理后不显示这些标记。

	 如将distros.sed文件修改为下面的distros-nl.sed文件：

	 #+BEGIN_SRC text
       # sed script to produce Linux distributions report
       # 起始处插入文本
       1 i\
       \\:\\:\\:\
       \
       Linux Distributions Report\
       \
       Name    Ver.    Released\
       \\:\\:
       s/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/
       # 末尾append文本
       $ a\
       \\:\
       \
       End of Report
	 #+END_SRC

	 脚本中的逻辑页标记都使用了双斜线，因为sed会将但斜线解释为转义字符。
	 末尾使用了sed的a命令，追加（append）文本。

	 下面使用sort排序distros.txt文件，再使用sed命令添加逻辑页标记，再
	 使用nl程序生成最终内容：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ sort -k 1,2 -k 2n distros.txt | sed -f distros-nl.sed | nl

              Linux Distributions Report

              Name     Ver.    Released

            1  Fedora  10      2008-11-25
            2  Fedora  5       2006-03-20
            3  Fedora  6       2006-10-24
            4  Fedora  7       2007-05-31
            5  Fedora  8       2007-11-08
            6  Fedora  9       2008-05-13
            7  SUSE    10.1    2006-05-11
            8  SUSE    10.2    2006-12-07
            9  SUSE    10.3    2007-10-04
           10  SUSE    11.0    2008-06-19
           11  Ubuntu  6.06    2006-06-01
           12  Ubuntu  6.10    2006-10-26
           13  Ubuntu  7.04    2007-04-19
           14  Ubuntu  7.10    2007-10-18
           15  Ubuntu  8.04    2008-04-24
           16  Ubuntu  8.10    2008-10-30

              End of Report
	 #+END_EXAMPLE

	 默认只在逻辑页的body部分生成行号。

	 下面为nl的常用参数：

     | 参数        | 含义                                                 |
     |-------------+------------------------------------------------------|
     | -n /style/  | 将body的行号样式设置为 /style/，可为                 |
     |             | a： 对所有行标记行号                                 |
     |             | t（默认）：仅标记非空行                              |
     |             | n：不标记行号                                        |
     |             | pregexp：只标记匹配正则的行。如"pSUSE"               |
     | -f /style/  | 将footer的行号样式设置为 /style/ 。默认为n（none）。 |
     | -h /style/  | 将header的行号样式设置为 /style/ 。默认为n（none）。 |
     | -i /number/ | ？？？                                               |
     | -n /format/ | 行号格式：                                           |
     |             | ln：左对齐，无前置0                                  |
     |             | rn（默认）：右对齐，无前置0                          |
     |             | rz：右对齐，有前置0                                  |
     | -p          | 不在逻辑页最前重置行号？？？                         |
     | -s /string/ | 将 /string/ 作为行号和正文的间隔符。默认为tab。      |
     | -v /number/ | 将每个逻辑行的行号初始值设置为 /number/ 。默认为1。  |
     | -w /width/  | 将行号所占宽度设置为 /width/ 。默认为6。             |

	 尝试一下下面2个不同的命令，观察效果：

	 #+BEGIN_EXAMPLE
       nl -n rz
       nl -w 3 -s ' '
	 #+END_EXAMPLE

**** fold - 将每行折叠为指定宽度

	 如：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "The quick brown fox jumped over the lazy dog." | fold -w 12
       The quick br
       own fox jump
       ed over the
       lazy dog.
	 #+END_EXAMPLE

	 参数-w指定折叠宽度，只能比原来窄。如需在合适的单词边界处折叠，需
	 配合-s参数使用：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ echo "The quick brown fox jumped over the lazy dog." | fold -w 12 -s
       The quick
       brown fox
       jumped over
       the lazy
       dog.
	 #+END_EXAMPLE

	 默认宽度为80，即80个字符。

**** fmt - 简单的文本格式工具

	 fmt程序也用于折叠行，不过功能更强大。接受单/多个文件或标准输入流。
	 基于段落折叠，可比原来窄，也可比原来宽。

	 如下面的emma.txt文件：

	 #+BEGIN_SRC text
           Please take a look at the important information in this header.
       We encourage you to keep this file on your own disk, keeping an
       electronic path open for the next readers.  Do not remove this.
	 #+END_SRC

	 使用参数-w指定折叠宽度：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ fmt -w 70 emma.txt
               Please take a look at the important information in this
               header.
       We encourage you to keep this file on your own disk, keeping an
       electronic path open for the next readers.  Do not remove this.
	 #+END_EXAMPLE

	 fmt会保留原来的缩进，使用参数-c可修改此默认行为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ fmt -cw 70 emma.txt
               Please take a look at the important information in this
        We encourage you to keep this file on your own disk, keeping
        electronic path open for the next readers.     Do not remove this.
	 #+END_EXAMPLE

	 常用的fmt参数：

     | 参数        | 描述                                                       |
     |-------------+------------------------------------------------------------|
     | -c          | 保留段落中前2行的缩进，后面的行对齐这两行                  |
     | -p /string/ | 仅格式化以 /string/ 开头的行。比如用于格式化源代码中的注释 |
     | -s          | 只将长的行变短，不管比指定宽度窄的行。                     |
     | -u          | 单词间保留1个空格，句子间保留2个空格。对格式化“对其”文本有用？？？。 |
     | -w /width/  | 指定折叠宽度。                                                       |

**** pr - 为打印格式化文本

	 用于将文本分页。使用参数-w指定宽度，参数-l指定长度。如将文件
	 distros.txt分页：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ pr -l 20 -w 65 distros.txt

       2017-01-31 18:41                distros.txt                Page 1

       SUSE    10.2    12/07/2006
       Fedora  10      11/25/2008
       Ubuntu  7.04    04/19/2007
       ...

       2017-01-31 18:41                distros.txt                Page 2

       SUSE    10.1    05/11/2006
       Fedora  6       10/24/2006
       Fedora  9       05/13/2008
       ...

       claudio@kali:~/foo$
	 #+END_EXAMPLE

	 每页的页头都生成日期、文件名和页号。

	 下章详细介绍此程序。

**** printf - 格式化并输出文本

	 为"print format"的缩写，起源于C语言，后被许多语言借用。bash中内置
	 了printf命令。

	 不能用管道，很少在命令行中使用，但在脚本中常用且重要。

	 用法同C语言中几乎一样。如：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ printf "%d, %f, %o, %s, %x, %X\n" 380 380 380 380 380 380 38
       380, 380.000000, 574, 380, 17c, 17C
	 #+END_EXAMPLE

*** 文件格式化系统

	上节的程序只适用于小型工程，对于大型工程有2大阵营可选：

	1. 衍生自roff程序的nroff和troff程序。

	nroff程序用于为使用“等宽字体（monospaced）”的设备，如命令行和打字
	机，格式化文本。不过到目前为止兼容能连接电脑的所有打印设备。

	troff程序则是为排字机（typesetter）这类商业用途的设备格式化文本。
	如今大多数电脑打印机都能模仿排字机。

	roff延伸出的专用程序还有如：

	- eqn：数学等式。
	- tbl：表格。

	2. 以及衍生子Tex排版系统的程序。
	   正逐渐替代troff成为格式化排字机文档的程序。可尝试本地安装textlive。

	本章只介绍第一种。

**** groff

	 groff一套程序，涵盖了GNU的troff实现，同时也内置了一个用于模仿
	 nroff和其他roff家族程序的脚本。

	 如今，除网页文本（使用HTML编写，浏览器渲染）外，绝大多数文本都可
	 通过文字处理器一步实现编写和格式化。之前，这2步需分开进行。其中
	 就可使用roff程序的渲染文本。

	 这里不详细介绍groff程序，只介绍还在广发使用的“宏包（macro
	 packages）”。

	 如使用man程序查看ls程序的手册，其原始文件为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ zcat /usr/share/man/man1/ls.1.gz | head
       .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.3.
       .TH LS "1" "December 2016" "GNU coreutils 8.26" "User Commands"
       .SH NAME
       ls \- list directory contents
       .SH SYNOPSIS
       .B ls
       [\fI\,OPTION\/\fR]... [\fI\,FILE\/\fR]...
       .SH DESCRIPTION
       .\" Add any additional description here
       .PP
	 #+END_EXAMPLE

	 对比平时查看的手册：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ man ls | head
       LS(1)                                          User Commands                                         LS(1)

       NAME
              ls - list directory contents

       SYNOPSIS
              ls [OPTION]... [FILE]...

       DESCRIPTION
              List  information  about the FILEs (the current directory by default).  Sort entries alphabetically
	 #+END_EXAMPLE

	 原有在于man程序使用了groff配合mandoc宏包渲染：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ zcat /usr/share/man/man1/ls.1.gz  | groff -mandoc -T ascii | head
       LS(1)                            User Commands                           LS(1)

       NAME
              ls - list directory contents

       SYNOPSIS
              ls [OPTION]... [FILE]...
	 #+END_EXAMPLE

	 这里使用了-T参数，将ASCII作为输出驱动，如果不指定输出驱动，默认输
	 出为PostScript：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc | head
       %!PS-Adobe-3.0
       %%Creator: groff version 1.22.3
       %%CreationDate: Sun Feb  5 02:29:11 2017
       %%DocumentNeededResources: font Times-Roman
       %%+ font Times-Bold
       %%+ font Times-Italic
       %%DocumentSuppliedResources: procset grops 1.22 3
       %%Pages: 4
       %%PageOrder: Ascend
       %%DocumentMedia: Default 595 842 0 () ()
	 #+END_EXAMPLE

	 PostScript是一种为排字机标记文本的语言，可使用evince直接查看：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ zcat /usr/share/man/man1/ls.1.gz | groff -mandoc | head > foo.ps
       claudio@kali:~/foo$ evince foo.ps
	 #+END_EXAMPLE

	 还可用ps2pdf程序将其转换为PDF文件：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ps2pdf foo.ps foo.pdf
	 #+END_EXAMPLE

	 #+BEGIN_QUOTE
	 Linux系统有许多文件格式转换程序，名称一般都是“format2format”，可
	 使用命令“ls /usr/bin/*[ [:alpha:] ]2[ [:alpha] ]*”查看。
	 #+END_QUOTE

** 打印

   - *pr* ：为打印转换文本。
   - *lpr* ：打印文件。
   - *a2ps* ：在PostScript打印机上格式化文件。
   - *lpstat* ：显示打印机状态信息。
   - *lpq* ：显示打印机队列状态。
   - *lprm* ：取消打印任务。

*** 打印历史简介
*** 使用Linux打印

	现代Linux系统有2套打印程序套装：

	1. CPUS（Common Unix Printing System）：提供打印驱动和打印任务管理。
	   - 通过创建和操作打印队列（print queues）管理打印机。
	   - 识别不同文件格式，转换为可打印形式。

	2. Ghostscript（RIP）： Postscript解释器。

*** 准备打印文本
**** pr - 为打印转换文本文件

	 pr程序可调整文本以适应打印宽度，还可设置页头和外边距。

	 pr常用参数：

     | 参数          | 描述                                                     |
     |---------------+----------------------------------------------------------|
     | +first[:last] | 指定打印页数，从first页开始，last页结束                  |
     | -column       | 打印为几列。即一页上有几列                               |
     | -a            | 默认为垂直排列。使用-a参数后水平排列                     |
     | -d            | 行与行间添加空行                                         |
     | -D "format"   | 将页头的时间显示格式设置为"format"，与date程序的格式相同 |
     | -f            | 页与页间换行符使用DOS的换行符                            |
     | -h "header"   | 将header作为页头中间的文本                               |
     | -l /length/   | 每页长度（行数）设置为 /length/ 。默认为66行。           |
     | -o /offset/   | 左外边距设置为offset这么多个字符宽度                     |
     | -w /width/    | 设置宽度（字符数）为 /width/ 。默认为72。                |
     | -n            | 显示行号                                                 |

	 pr程序通常配合管道使用，如列出/usr/bin/文件夹内容，呈3列显示：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/bin/ | pr -3 -w 65 | head

       2017-02-05 15:20                                           Page 1

       [                     alsaucm               aspell-import
       0trace.sh             amap                  assistant
       2to3                  amap6                 atk6-address6
       2to3-2.7              amapcrap              atk6-alive6
       2to3-3.5              amidi                 atk6-covert_send6
	 #+END_EXAMPLE

*** 向打印机发送打印任务

	由于历史原因，CUPS打印套装支持2套程序：Berkeley风格和System V风格。
	前者使用lpr程序，后者使用lp程序打印，功能几乎相同，看个人喜好选择。

	#+BEGIN_QUOTE
	为学习方便，如果没有实体打印机，可尝试安装cups-pdf程序。使“打印机”
	打印到PDF文件。使用此“打印机”打印的PDF文件默认生成到~/PDF文件夹内。
	#+END_QUOTE

**** lpr - 打印文件（Berkeley 风格）

	 使用lpr程序，结合管道，可将文本传入打印机：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/bin/ | pr -3 | lpr
	 #+END_EXAMPLE

	 可使用-P参数指定打印机：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lpr -p 打印机名
	 #+END_EXAMPLE

	 其中打印机名为下面命令运行结果的第一列：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lpstat -a
       PDF accepting requests since Sun 05 Feb 2017 03:58:41 PM CST
	 #+END_EXAMPLE

	 如上面结果的“PDF”。

	 下面为lpr程序的常用参数：

     | 参数         | 描述                                                       |
     |--------------+------------------------------------------------------------|
     | -# /number/  | 将打印份数设置为 /number/                                  |
     | -p           | pretty print。在每页上方打印深色的页头，含时间、日期等信息 |
     | -P /printer/ | 指定打印机，如果不指则为系统默认打印机                     |
     | -r           | 打印完后删除原文件                                         |

**** lp - 打印文件（System V 风格）

	 同lpr程序，也可接受单/多个文件和标准输入流。不过支持更多的参数。
	 下面为lp程序的常用参数：

     | 参数                     | 描述                                                             |
     |--------------------------+------------------------------------------------------------------|
     | -d /printer/             | destination。指定打印机，缺省值为系统默认打印机                  |
     | -n /number/              | 指定打印份数                                                     |
     | -o landscape             | 垂直打印                                                         |
     | -o fitplot               | 将文本内容缩放至适应页面大小。对打印JPEG文件很有用。             |
     | -o scaling= /number/     | 按 /number/ 缩放文件。                                           |
     |                          | 100为刚好为页面大小，小于则缩小，如果大于100则可能占多页         |
     | -o cpi= /number/         | cpi为"characters per inch"的缩写，即每英寸字符数量。默认为10     |
     | -o lpi= /numnber/        | lpi为“lines per inch”的缩写，即每英寸行数。默认为6               |
     | -o page-top= /points/    | 设置页面外边距。单位为 /point/ （pt）。默认值为72。              |
     | -o page-right= /points/  |                                                                  |
     | -o page-bottom= /points/ |                                                                  |
     | -o page-left= /points/   |                                                                  |
     | -P 页号                  | 指定只打印的实际纸张页。页号为用逗号隔开的字符串，如"1,3,5,7-10" |

	 下面的命令为将/usr/bin中文件清单打印为4列，12CPI、8LPI，左外边距
	 36pt：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/bin/ | pr -4 -w 90 -l 88 | lp -o page-left=36 -o cpi=12 -o lpi=8
	 #+END_EXAMPLE

**** 另一种选择：a2ps

	 从名称看，a2ps程序为格式转换工具，单不止。其名称原来的含义为
	 “ASCII to PostScript”，原用来为PostScript打印机格式化文本文件。进
	 过多年发展后，此程序个将任何文本转换为PostScript文件，即“Anything
	 to PostScript”。

	 实际上是个打印程序，默认输出到系统默认打印机，而非标准输出流。

	 如下使用a2ps程序创建一个PostScript文件：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/bin/ | pr -3 -t | a2ps -L 66 -o ~/Desktop/ls.ps
       [stdin (plain): 18 pages on 9 sheets]
       [Total: 18 pages on 9 sheets] saved into the file `/home/claudio/Desktop/ls.ps'
	 #+END_EXAMPLE

	 pr程序参数-t的含义为不显示页头和页尾。a2ps程序中，参数-L的含义为
	 每页的行数，-o参数用来指定输出文件名称。

	 使用evince查看ls.ps文件可见，“每张纸”上打印了2页，且添加了页头页
	 尾，即默认美化打印（pretty print）。

	 直接打印也是将输出文件默认输出到~/PDF文件夹内：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ ls /usr/bin/ | a2ps
       [stdin (plain): 57 pages on 29 sheets]
       request id is PDF-58 (0 file(s))
       [Total: 57 pages on 29 sheets] sent to the default printer
	 #+END_EXAMPLE

	 下面为a2ps程序的部分参数：

     | 参数                       | 描述                             |
     |----------------------------+----------------------------------|
     | --center-title= /text/     | 将每页中间的标题打印为 /text/    |
     | --footer= /text/           | 页尾文本设置为 /text/            |
     | --guess                    | 显示原文件的类型。               |
     | --left-footer= /text/      | 将页面左下角文本设置为 /text/    |
     | --left-title= /text/       | 页面左上角文本设置为 /text/      |
     | --line-numbers= /interval/ |                                  |
     | --list=defaults            | 显示默认设置                     |
     | --list= /topic/            | 显示 /topic/ 的设置。？？？      |
     | --pages= /range/           | 只打印的页数范围。               |
     | --right-footer= /text/     | 右下角文本设置为 /text/          |
     | --right-title= /text/      | 右上角文本设置为 /text/          |
     | --rows= /number/           | 每页行数。默认为1                |
     | -B                         | 不打印页头                       |
     | -b /text/                  | ？？？                           |
     | -f /size/                  | 字体大小，单位为pt               |
     | -l /number/                | 每行字符数量                     |
     | -L /number/                | 每页行数                         |
     | -M /name/                  | 纸张规格，如“A4”                 |
     | -n /number/                | 份数                             |
     | -o /file/                  | 输出文件。"-"表示标准输出流      |
     | -P /printer/               | 指定打印机。默认为系统默认打印机 |
     | -R                         | ？？？                           |
     | -r                         | ？？？                           |
     | -T /number/                | ？？？                           |
     | -u /text/                  | 水印                             |

*** 监视和控制打印任务
**** lpstat - 显示打印系统状态

	 使用lpstat程序可查看可用的打印设备，以及打印设备的状态。比如只有
	 一个虚拟打印机状态下打印机查看结果为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lpstat -a
       PDF accepting requests since Sun 05 Feb 2017 05:50:18 PM CST
	 #+END_EXAMPLE

	 查看打印机详细配置信息的命令为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lpstat -s
       system default destination: PDF
       device for PDF: cups-pdf:/
	 #+END_EXAMPLE

	 可见系统的默认“打印机”为PDF（虚拟）打印机，其连接的设备为cusp-pdf
	 程序。

	 下面为lpstat程序的常用参数：

     | 参数            | 描述                                               |
     |-----------------+----------------------------------------------------|
     | -a [printer...] | 查看打印机printer的打印队列。                      |
     |                 | 只是打印机的任务序列，而不是物理打印机的任务序列。 |
     |                 | 如果不指定具体打印机，则显示所有打印机的任务序列。 |
     | -d              | 显示系统的默认打印机。                             |
     | -r              | 显示打印服务器的状态信息。                         |
     | -s              | 显示概况                                           |
     | -t              | 显示所有打印机信息                                 |

**** lpq - 显示打印机队列状态

	 lpq程序可查看打印机的打印序列状态。比如内有打印任务时，执行的结果
	 为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lpq
       PDF is ready
       no entries
	 #+END_EXAMPLE

	 如果没指定某个打印机（使用-P参数），显示系统默认打印机的打印序列。

	 如果打印机正在执行任务，执行效果为：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lp emma.txt
       request id is PDF-92 (1 file(s))
       claudio@kali:~/foo$ lpq
       PDF is ready and printing
       Rank    Owner   Job     File(s)                         Total Size
       active  claudio 92      emma.txt                        915456 bytes
	 #+END_EXAMPLE

**** lprm/cancel - 取消打印任务

	 CUPS有2个取消打印任务的程序，一个是Berkeley风格的lprm程序，一个是
	 System V风格的cancel程序。两者功能基本相同，参数只是稍有区别。

	 使用上例中的执行结果取消打印任务：

	 #+BEGIN_EXAMPLE
       claudio@kali:~/foo$ lpq
       PDF is ready and printing
       Rank    Owner   Job     File(s)                         Total Size
       active  claudio 92      emma.txt                        915456 bytes
       claudio@kali:~/foo$ cancel 93
       claudio@kali:~/foo$ lpq
       PDF is ready
       no entries
	 #+END_EXAMPLE

* Writing Shell Scripts
